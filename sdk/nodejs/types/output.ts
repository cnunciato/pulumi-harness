// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface EncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface EnvironmentVariableOverride {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * The name of the service
     */
    serviceName?: string;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type: string;
    /**
     * The value of the service variable
     */
    value: string;
}

export interface GetEncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetGitConnectorCommitDetail {
    authorEmailId: string;
    authorName: string;
    message: string;
}

export interface GetSecretManagerUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetSshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GitConnectorCommitDetails {
    /**
     * The email id of the author
     */
    authorEmailId?: string;
    /**
     * The name of the author
     */
    authorName?: string;
    /**
     * Commit message
     */
    message?: string;
}

export interface GitConnectorUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface InfrastructureDefinitionAwsAmi {
    /**
     * The ami deployment type to use. Valid options are AWS_ASG, SPOTINST
     */
    amiDeploymentType: string;
    /**
     * Flag to indicate whether the autoscaling group identifies the workload.
     */
    asgIdentifiesWorkload?: boolean;
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: string;
    /**
     * The classic load balancers to use.
     */
    classicLoadbalancers?: string[];
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The name of the SpotInst cloud provider to connect with.
     */
    spotinstCloudProviderName?: string;
    /**
     * The SpotInst configuration to use.
     */
    spotinstConfigJson?: string;
    /**
     * The staging classic load balancers to use.
     */
    stageClassicLoadbalancers?: string[];
    /**
     * The staging classic load balancers to use.
     */
    stageTargetGroupArns?: string[];
    /**
     * The ARN's of the target groups.
     */
    targetGroupArns?: string[];
    /**
     * Flag to enable traffic shifting.
     */
    useTrafficShift?: boolean;
}

export interface InfrastructureDefinitionAwsEcs {
    /**
     * Flag to assign a public IP address.
     */
    assignPublicIp?: boolean;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the ECS cluster to use.
     */
    clusterName: string;
    /**
     * The ARN of the role to use for execution.
     */
    executionRole?: string;
    /**
     * The type of launch configuration to use. Valid options are FARGATE
     */
    launchType: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: string[];
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: string[];
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: string;
}

export interface InfrastructureDefinitionAwsLambda {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The IAM role to use.
     */
    iamRole?: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: string[];
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: string[];
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: string;
}

export interface InfrastructureDefinitionAwsSsh {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: string;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The desired capacity of the auto scaling group.
     */
    desiredCapacity?: number;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: string;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: string;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: string;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The tags to use when selecting the instances.
     */
    tags?: outputs.InfrastructureDefinitionAwsSshTag[];
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcIds?: string[];
}

export interface InfrastructureDefinitionAwsSshTag {
    key: string;
    value: string;
}

export interface InfrastructureDefinitionAwsWinrm {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName: string;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The desired capacity of the autoscaling group.
     */
    desiredCapacity?: number;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName: string;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: string;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: string;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: string;
    /**
     * The region to deploy to.
     */
    region: string;
}

export interface InfrastructureDefinitionAzureVmss {
    /**
     * The type of authentication to use. Valid options are SSH*PUBLIC*KEY.
     */
    authType: string;
    /**
     * Base name.
     */
    baseName: string;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The type of deployment. Valid options are NATIVE_VMSS
     */
    deploymentType: string;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: string;
    /**
     * The name of the resource group.
     */
    resourceGroupName: string;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: string;
    /**
     * The username to connect with.
     */
    username: string;
}

export interface InfrastructureDefinitionAzureWebapp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the resource group.
     */
    resourceGroup: string;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: string;
}

export interface InfrastructureDefinitionDatacenterSsh {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the SSH connection attributes to use.
     */
    hostConnectionAttributesName: string;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: string[];
}

export interface InfrastructureDefinitionDatacenterWinrm {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: string[];
    /**
     * The name of the WinRM connection attributes to use.
     */
    winrmConnectionAttributesName: string;
}

export interface InfrastructureDefinitionKubernetes {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: string;
    /**
     * The naming convention of the release. When using Helm Native the default is ${infra.kubernetes.infraId}. For standard Kubernetes manifests the default is release-${infra.kubernetes.infraId}
     */
    releaseName: string;
}

export interface InfrastructureDefinitionKubernetesGcp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the cluster being deployed to.
     */
    clusterName: string;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: string;
    /**
     * The naming convention of the release.
     */
    releaseName: string;
}

export interface InfrastructureDefinitionTanzu {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The PCF organization to use.
     */
    organization: string;
    /**
     * The PCF space to deploy to.
     */
    space: string;
}

export interface SshCredentialKerberosAuthentication {
    /**
     * Port to use for Kerberos authentication
     */
    port: number;
    /**
     * Name of the principal for authentication
     */
    principal: string;
    /**
     * Realm associated with the Kerberos authentication
     */
    realm: string;
    /**
     * TGT generation method
     */
    tgtGenerationMethod?: outputs.SshCredentialKerberosAuthenticationTgtGenerationMethod;
}

export interface SshCredentialKerberosAuthenticationTgtGenerationMethod {
    kerberosPasswordId?: string;
    keyTabFilePath?: string;
}

export interface SshCredentialSshAuthentication {
    /**
     * Inline SSH authentication configuration. Only ond of `passphraseSecretId` or `sshKeyFileId` should be used
     */
    inlineSsh?: outputs.SshCredentialSshAuthenticationInlineSsh;
    /**
     * The port to connect to
     */
    port: number;
    /**
     * Server password authentication configuration
     */
    serverPassword?: outputs.SshCredentialSshAuthenticationServerPassword;
    /**
     * Use ssh key file for authentication
     */
    sshKeyFile?: outputs.SshCredentialSshAuthenticationSshKeyFile;
    /**
     * The username to use when connecting to ssh
     */
    username: string;
}

export interface SshCredentialSshAuthenticationInlineSsh {
    passphraseSecretId?: string;
    sshKeyFileId: string;
}

export interface SshCredentialSshAuthenticationServerPassword {
    passwordSecretId: string;
}

export interface SshCredentialSshAuthenticationSshKeyFile {
    passphraseSecretId?: string;
    path: string;
}

export interface SshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface UserGroupLdapSettings {
    /**
     * The group DN of the LDAP user group.
     */
    groupDn?: string;
    /**
     * The group name of the LDAP user group.
     */
    groupName?: string;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: string;
}

export interface UserGroupNotificationSettings {
    /**
     * The email addresses of the user group.
     */
    groupEmailAddresses?: string[];
    /**
     * The Microsoft Teams webhook URL of the user group.
     */
    microsoftTeamsWebhookUrl?: string;
    /**
     * Indicates whether an email is sent when a new user is added to the group.
     */
    sendMailToNewMembers?: boolean;
    /**
     * Enable this setting to have notifications sent to the members of this group.
     */
    sendNotificationsToMembers?: boolean;
    /**
     * The Slack channel to send notifications to.
     */
    slackChannel?: string;
    /**
     * The Slack webhook URL to send notifications to.
     */
    slackWebhookUrl?: string;
}

export interface UserGroupPermissions {
    /**
     * The account permissions of the user group. Valid options are ADMINISTER*OTHER*ACCOUNT*FUNCTIONS, CREATE*AND*DELETE*APPLICATION, CREATE*CUSTOM*DASHBOARDS, MANAGE*ALERT*NOTIFICATION*RULES, MANAGE*API*KEYS, MANAGE*APPLICATION*STACKS, MANAGE*AUTHENTICATION*SETTINGS, MANAGE*CLOUD*PROVIDERS, MANAGE*CONFIG*AS*CODE, MANAGE*CONNECTORS, MANAGE*CUSTOM*DASHBOARDS, MANAGE*DELEGATE*PROFILES, MANAGE*DELEGATES, MANAGE*DEPLOYMENT*FREEZES, MANAGE*IP*WHITELIST, MANAGE*PIPELINE*GOVERNANCE*STANDARDS, MANAGE*RESTRICTED*ACCESS, MANAGE*SECRET*MANAGERS, MANAGE*SECRETS, MANAGE*SSH*AND*WINRM, MANAGE*TAGS, MANAGE*TEMPLATE*LIBRARY, MANAGE*USER*AND*USER*GROUPS*AND*API*KEYS, MANAGE*USERS*AND*GROUPS, READ*USERS*AND*GROUPS, VIEW*AUDITS, VIEW*USER*AND*USER*GROUPS*AND*API_KEYS
     */
    accountPermissions?: string[];
    /**
     * Application specific permissions
     */
    appPermissions?: outputs.UserGroupPermissionsAppPermissions;
}

export interface UserGroupPermissionsAppPermissions {
    alls?: outputs.UserGroupPermissionsAppPermissionsAll[];
    deployments?: outputs.UserGroupPermissionsAppPermissionsDeployment[];
    environments?: outputs.UserGroupPermissionsAppPermissionsEnvironment[];
    pipelines?: outputs.UserGroupPermissionsAppPermissionsPipeline[];
    provisioners?: outputs.UserGroupPermissionsAppPermissionsProvisioner[];
    services?: outputs.UserGroupPermissionsAppPermissionsService[];
    templates?: outputs.UserGroupPermissionsAppPermissionsTemplate[];
    workflows?: outputs.UserGroupPermissionsAppPermissionsWorkflow[];
}

export interface UserGroupPermissionsAppPermissionsAll {
    actions: string[];
    appIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsDeployment {
    actions: string[];
    appIds?: string[];
    envIds?: string[];
    filters: string[];
}

export interface UserGroupPermissionsAppPermissionsEnvironment {
    actions: string[];
    appIds?: string[];
    envIds?: string[];
    filters: string[];
}

export interface UserGroupPermissionsAppPermissionsPipeline {
    actions: string[];
    appIds?: string[];
    envIds?: string[];
    filters: string[];
}

export interface UserGroupPermissionsAppPermissionsProvisioner {
    actions: string[];
    appIds?: string[];
    provisionerIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsService {
    actions: string[];
    appIds?: string[];
    serviceIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsTemplate {
    actions: string[];
    appIds?: string[];
    templateIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsWorkflow {
    actions: string[];
    appIds?: string[];
    filters: string[];
}

export interface UserGroupSamlSettings {
    /**
     * The group name of the SAML user group.
     */
    groupName?: string;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: string;
}

export namespace Cloudprovider {
    export interface AwsAssumeCrossAccountRole {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: string;
        /**
         * This is an IAM role in the target deployment AWS account.
         */
        roleArn: string;
    }

    export interface AwsUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: string;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: string;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: string;
    }

    export interface DatacenterUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: string;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: string;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: string;
    }

    export interface GcpUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: string;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: string;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: string;
    }

    export interface KubernetesAuthentication {
        /**
         * Delegate selectors to inherit the GCP credentials from.
         */
        delegateSelectors?: string[];
        /**
         * Service account configuration for connecting to the Kubernetes cluster
         */
        oidc?: outputs.Cloudprovider.KubernetesAuthenticationOidc;
        /**
         * Username and password for authentication to the cluster
         */
        serviceAccount?: outputs.Cloudprovider.KubernetesAuthenticationServiceAccount;
        /**
         * Username and password for authentication to the cluster
         */
        usernamePassword?: outputs.Cloudprovider.KubernetesAuthenticationUsernamePassword;
    }

    export interface KubernetesAuthenticationOidc {
        clientIdSecretName: string;
        clientSecretSecretName?: string;
        identityProviderUrl: string;
        masterUrl: string;
        passwordSecretName: string;
        scopes?: string[];
        username: string;
    }

    export interface KubernetesAuthenticationServiceAccount {
        caCertificateSecretName?: string;
        masterUrl: string;
        serviceAccountTokenSecretName: string;
    }

    export interface KubernetesAuthenticationUsernamePassword {
        masterUrl: string;
        passwordSecretName: string;
        username?: string;
        usernameSecretName?: string;
    }

    export interface KubernetesUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: string;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: string;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: string;
    }

}

export namespace Platform {
    export interface GetResourceGroupIncludedScope {
        /**
         * Account Identifier of the account
         */
        accountId: string;
        filter: string;
        /**
         * Unique identifier of the organization.
         */
        orgId: string;
        /**
         * Unique identifier of the project.
         */
        projectId: string;
    }

    export interface GetResourceGroupResourceFilter {
        includeAllResources: boolean;
        resources: outputs.Platform.GetResourceGroupResourceFilterResource[];
    }

    export interface GetResourceGroupResourceFilterResource {
        attributeFilters: outputs.Platform.GetResourceGroupResourceFilterResourceAttributeFilter[];
        identifiers: string[];
        resourceType: string;
    }

    export interface GetResourceGroupResourceFilterResourceAttributeFilter {
        attributeName: string;
        attributeValues: string[];
    }

    export interface GetSecretSshkeyKerbero {
        principal: string;
        realm: string;
        tgtGenerationMethod: string;
        tgtKeyTabFilePathSpecs: outputs.Platform.GetSecretSshkeyKerberoTgtKeyTabFilePathSpec[];
        tgtPasswordSpecs: outputs.Platform.GetSecretSshkeyKerberoTgtPasswordSpec[];
    }

    export interface GetSecretSshkeyKerberoTgtKeyTabFilePathSpec {
        keyPath: string;
    }

    export interface GetSecretSshkeyKerberoTgtPasswordSpec {
        password: string;
    }

    export interface GetSecretSshkeySsh {
        credentialType: string;
        sshPasswordCredentials: outputs.Platform.GetSecretSshkeySshSshPasswordCredential[];
        sshkeyPathCredentials: outputs.Platform.GetSecretSshkeySshSshkeyPathCredential[];
        sshkeyReferenceCredentials: outputs.Platform.GetSecretSshkeySshSshkeyReferenceCredential[];
    }

    export interface GetSecretSshkeySshSshPasswordCredential {
        password: string;
        userName: string;
    }

    export interface GetSecretSshkeySshSshkeyPathCredential {
        encryptedPassphrase: string;
        keyPath: string;
        userName: string;
    }

    export interface GetSecretSshkeySshSshkeyReferenceCredential {
        encryptedAssphrase: string;
        key: string;
        userName: string;
    }

    export interface GetUsergroupNotificationConfig {
        /**
         * Group email
         */
        groupEmail: string;
        /**
         * Url of Microsoft teams webhook
         */
        microsoftTeamsWebhookUrl: string;
        /**
         * Pager duty key
         */
        pagerDutyKey: string;
        /**
         * Url of slack webhook
         */
        slackWebhookUrl: string;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS
         */
        type: string;
    }

    export interface ResourceGroupIncludedScope {
        /**
         * Account Identifier of the account
         */
        accountId?: string;
        /**
         * Can be one of these 2 EXCLUDING*CHILD*SCOPES or INCLUDING*CHILD*SCOPES
         */
        filter: string;
        /**
         * Organization Identifier
         */
        orgId?: string;
        /**
         * Project Identifier
         */
        projectId?: string;
    }

    export interface ResourceGroupResourceFilter {
        /**
         * Include all resource or not
         */
        includeAllResources?: boolean;
        /**
         * Resources for a resource group
         */
        resources?: outputs.Platform.ResourceGroupResourceFilterResource[];
    }

    export interface ResourceGroupResourceFilterResource {
        attributeFilters?: outputs.Platform.ResourceGroupResourceFilterResourceAttributeFilter[];
        identifiers?: string[];
        resourceType: string;
    }

    export interface ResourceGroupResourceFilterResourceAttributeFilter {
        attributeName?: string;
        attributeValues?: string[];
    }

    export interface SecretSshkeyKerberos {
        /**
         * Username to use for authentication.
         */
        principal: string;
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        realm: string;
        /**
         * Method to generate tgt
         */
        tgtGenerationMethod?: string;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtKeyTabFilePathSpec?: outputs.Platform.SecretSshkeyKerberosTgtKeyTabFilePathSpec;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtPasswordSpec?: outputs.Platform.SecretSshkeyKerberosTgtPasswordSpec;
    }

    export interface SecretSshkeyKerberosTgtKeyTabFilePathSpec {
        keyPath?: string;
    }

    export interface SecretSshkeyKerberosTgtPasswordSpec {
        password?: string;
    }

    export interface SecretSshkeySsh {
        /**
         * This specifies SSH credential type as Password, KeyPath or KeyReference
         */
        credentialType: string;
        /**
         * SSH credential of type keyReference
         */
        sshPasswordCredential?: outputs.Platform.SecretSshkeySshSshPasswordCredential;
        /**
         * SSH credential of type keyPath
         */
        sshkeyPathCredential?: outputs.Platform.SecretSshkeySshSshkeyPathCredential;
        /**
         * SSH credential of type keyReference
         */
        sshkeyReferenceCredential?: outputs.Platform.SecretSshkeySshSshkeyReferenceCredential;
    }

    export interface SecretSshkeySshSshPasswordCredential {
        password: string;
        userName: string;
    }

    export interface SecretSshkeySshSshkeyPathCredential {
        encryptedPassphrase?: string;
        keyPath: string;
        userName: string;
    }

    export interface SecretSshkeySshSshkeyReferenceCredential {
        encryptedPassphrase?: string;
        key?: string;
        userName: string;
    }

    export interface UsergroupNotificationConfig {
        /**
         * Group email
         */
        groupEmail?: string;
        /**
         * Url of Microsoft teams webhook
         */
        microsoftTeamsWebhookUrl?: string;
        /**
         * Pager duty key
         */
        pagerDutyKey?: string;
        /**
         * Url of slack webhook
         */
        slackWebhookUrl?: string;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS
         */
        type?: string;
    }

}

export namespace PlatformConnector {
    export interface AppDynamicsApiToken {
        /**
         * The client id used for connecting to App Dynamics.
         */
        clientId: string;
        /**
         * Reference to the Harness secret containing the App Dynamics client secret.
         */
        clientSecretRef: string;
    }

    export interface AppDynamicsUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username: string;
    }

    export interface ArtifactoryCredentials {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username?: string;
        /**
         * Reference to a secret containing the username to use for authentication.
         */
        usernameRef?: string;
    }

    export interface AwsCCCrossAccountAccess {
        /**
         * The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
         */
        externalId: string;
        /**
         * The ARN of the role to use for cross-account access.
         */
        roleArn: string;
    }

    export interface AwsCrossAccountAccess {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: string;
        /**
         * The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
         */
        roleArn: string;
    }

    export interface AwsInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: string[];
    }

    export interface AwsIrsa {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: string[];
    }

    export interface AwsKmsCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: outputs.PlatformConnector.AwsKmsCredentialsAssumeRole;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: boolean;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: outputs.PlatformConnector.AwsKmsCredentialsManual;
    }

    export interface AwsKmsCredentialsAssumeRole {
        duration: number;
        externalId?: string;
        roleArn: string;
    }

    export interface AwsKmsCredentialsManual {
        accessKeyRef: string;
        secretKeyRef: string;
    }

    export interface AwsManual {
        /**
         * AWS access key.
         */
        accessKey?: string;
        /**
         * Reference to the Harness secret containing the aws access key.
         */
        accessKeyRef?: string;
        /**
         * Connect only use delegates with these tags.
         */
        delegateSelectors?: string[];
        /**
         * Reference to the Harness secret containing the aws secret key.
         */
        secretKeyRef: string;
    }

    export interface AwsSecretManagerCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: outputs.PlatformConnector.AwsSecretManagerCredentialsAssumeRole;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: boolean;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: outputs.PlatformConnector.AwsSecretManagerCredentialsManual;
    }

    export interface AwsSecretManagerCredentialsAssumeRole {
        duration: number;
        externalId?: string;
        roleArn: string;
    }

    export interface AwsSecretManagerCredentialsManual {
        accessKeyRef: string;
        secretKeyRef: string;
    }

    export interface BitbucketApiAuthentication {
        /**
         * Personal access token for interacting with the BitBucket api.
         */
        tokenRef: string;
        /**
         * The username used for connecting to the api.
         */
        username?: string;
        /**
         * The name of the Harness secret containing the username.
         */
        usernameRef?: string;
    }

    export interface BitbucketCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: outputs.PlatformConnector.BitbucketCredentialsHttp;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: outputs.PlatformConnector.BitbucketCredentialsSsh;
    }

    export interface BitbucketCredentialsHttp {
        passwordRef?: string;
        username?: string;
        usernameRef?: string;
    }

    export interface BitbucketCredentialsSsh {
        sshKeyRef: string;
    }

    export interface DockerCredentials {
        /**
         * The reference to the password to use for the docker registry.
         */
        passwordRef: string;
        /**
         * The username to use for the docker registry.
         */
        username?: string;
        /**
         * The reference to the username to use for the docker registry.
         */
        usernameRef?: string;
    }

    export interface GcpInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: string[];
    }

    export interface GcpManual {
        /**
         * The delegates to connect with.
         */
        delegateSelectors: string[];
        /**
         * Reference to the Harness secret containing the secret key.
         */
        secretKeyRef: string;
    }

    export interface GetAppDynamicsApiToken {
        clientId: string;
        clientSecretRef: string;
    }

    export interface GetAppDynamicsUsernamePassword {
        passwordRef: string;
        username: string;
    }

    export interface GetArtifactoryCredential {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetAwsCCCrossAccountAccess {
        externalId: string;
        roleArn: string;
    }

    export interface GetAwsCrossAccountAccess {
        externalId: string;
        roleArn: string;
    }

    export interface GetAwsInheritFromDelegate {
        delegateSelectors: string[];
    }

    export interface GetAwsIrsa {
        delegateSelectors: string[];
    }

    export interface GetAwsKmsCredential {
        assumeRoles: outputs.PlatformConnector.GetAwsKmsCredentialAssumeRole[];
        inheritFromDelegate: boolean;
        manuals: outputs.PlatformConnector.GetAwsKmsCredentialManual[];
    }

    export interface GetAwsKmsCredentialAssumeRole {
        duration: number;
        externalId: string;
        roleArn: string;
    }

    export interface GetAwsKmsCredentialManual {
        accessKeyRef: string;
        secretKeyRef: string;
    }

    export interface GetAwsManual {
        accessKey: string;
        accessKeyRef: string;
        delegateSelectors: string[];
        secretKeyRef: string;
    }

    export interface GetAwsSecretManagerCredential {
        assumeRoles: outputs.PlatformConnector.GetAwsSecretManagerCredentialAssumeRole[];
        inheritFromDelegate: boolean;
        manuals: outputs.PlatformConnector.GetAwsSecretManagerCredentialManual[];
    }

    export interface GetAwsSecretManagerCredentialAssumeRole {
        duration: number;
        externalId: string;
        roleArn: string;
    }

    export interface GetAwsSecretManagerCredentialManual {
        accessKeyRef: string;
        secretKeyRef: string;
    }

    export interface GetBitbucketApiAuthentication {
        tokenRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetBitbucketCredential {
        https: outputs.PlatformConnector.GetBitbucketCredentialHttp[];
        sshes: outputs.PlatformConnector.GetBitbucketCredentialSsh[];
    }

    export interface GetBitbucketCredentialHttp {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetBitbucketCredentialSsh {
        sshKeyRef: string;
    }

    export interface GetDockerCredential {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetGcpInheritFromDelegate {
        delegateSelectors: string[];
    }

    export interface GetGcpManual {
        delegateSelectors: string[];
        secretKeyRef: string;
    }

    export interface GetGitCredential {
        https: outputs.PlatformConnector.GetGitCredentialHttp[];
        sshes: outputs.PlatformConnector.GetGitCredentialSsh[];
    }

    export interface GetGitCredentialHttp {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetGitCredentialSsh {
        sshKeyRef: string;
    }

    export interface GetGithubApiAuthentication {
        githubApps: outputs.PlatformConnector.GetGithubApiAuthenticationGithubApp[];
        tokenRef: string;
    }

    export interface GetGithubApiAuthenticationGithubApp {
        applicationId: string;
        installationId: string;
        privateKeyRef: string;
    }

    export interface GetGithubCredential {
        https: outputs.PlatformConnector.GetGithubCredentialHttp[];
        sshes: outputs.PlatformConnector.GetGithubCredentialSsh[];
    }

    export interface GetGithubCredentialHttp {
        tokenRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetGithubCredentialSsh {
        sshKeyRef: string;
    }

    export interface GetGitlabApiAuthentication {
        tokenRef: string;
    }

    export interface GetGitlabCredential {
        https: outputs.PlatformConnector.GetGitlabCredentialHttp[];
        sshes: outputs.PlatformConnector.GetGitlabCredentialSsh[];
    }

    export interface GetGitlabCredentialHttp {
        passwordRef: string;
        tokenRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetGitlabCredentialSsh {
        sshKeyRef: string;
    }

    export interface GetHelmCredential {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetKubernetesClientKeyCert {
        caCertRef: string;
        clientCertRef: string;
        clientKeyAlgorithm: string;
        clientKeyPassphraseRef: string;
        clientKeyRef: string;
        masterUrl: string;
    }

    export interface GetKubernetesInheritFromDelegate {
        /**
         * Selectors to use for the delegate.
         */
        delegateSelectors: string[];
    }

    export interface GetKubernetesOpenidConnect {
        clientIdRef: string;
        issuerUrl: string;
        masterUrl: string;
        passwordRef: string;
        scopes: string[];
        secretRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetKubernetesServiceAccount {
        masterUrl: string;
        serviceAccountTokenRef: string;
    }

    export interface GetKubernetesUsernamePassword {
        masterUrl: string;
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetNexusCredential {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GitCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: outputs.PlatformConnector.GitCredentialsHttp;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: outputs.PlatformConnector.GitCredentialsSsh;
    }

    export interface GitCredentialsHttp {
        passwordRef: string;
        username?: string;
        usernameRef?: string;
    }

    export interface GitCredentialsSsh {
        sshKeyRef: string;
    }

    export interface GithubApiAuthentication {
        /**
         * Configuration for using the github app for interacting with the github api.
         */
        githubApp?: outputs.PlatformConnector.GithubApiAuthenticationGithubApp;
        /**
         * Personal access token for interacting with the github api.
         */
        tokenRef?: string;
    }

    export interface GithubApiAuthenticationGithubApp {
        applicationId: string;
        installationId: string;
        privateKeyRef: string;
    }

    export interface GithubCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: outputs.PlatformConnector.GithubCredentialsHttp;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: outputs.PlatformConnector.GithubCredentialsSsh;
    }

    export interface GithubCredentialsHttp {
        tokenRef: string;
        username?: string;
        usernameRef?: string;
    }

    export interface GithubCredentialsSsh {
        sshKeyRef: string;
    }

    export interface GitlabApiAuthentication {
        /**
         * Personal access token for interacting with the gitlab api.
         */
        tokenRef: string;
    }

    export interface GitlabCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: outputs.PlatformConnector.GitlabCredentialsHttp;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: outputs.PlatformConnector.GitlabCredentialsSsh;
    }

    export interface GitlabCredentialsHttp {
        passwordRef?: string;
        tokenRef?: string;
        username?: string;
        usernameRef?: string;
    }

    export interface GitlabCredentialsSsh {
        sshKeyRef: string;
    }

    export interface HelmCredentials {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username?: string;
        /**
         * Reference to a secret containing the username to use for authentication.
         */
        usernameRef?: string;
    }

    export interface KubernetesClientKeyCert {
        /**
         * Reference to the secret containing the CA certificate for the connector.
         */
        caCertRef?: string;
        /**
         * Reference to the secret containing the client certificate for the connector.
         */
        clientCertRef: string;
        /**
         * The algorithm used to generate the client key for the connector. Valid values are RSA, EC
         */
        clientKeyAlgorithm: string;
        /**
         * Reference to the secret containing the client key passphrase for the connector.
         */
        clientKeyPassphraseRef?: string;
        /**
         * Reference to the secret containing the client key for the connector.
         */
        clientKeyRef: string;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: string;
    }

    export interface KubernetesInheritFromDelegate {
        /**
         * Selectors to use for the delegate.
         */
        delegateSelectors: string[];
    }

    export interface KubernetesOpenidConnect {
        /**
         * Reference to the secret containing the client ID for the connector.
         */
        clientIdRef: string;
        /**
         * The URL of the OpenID Connect issuer.
         */
        issuerUrl: string;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: string;
        /**
         * Reference to the secret containing the password for the connector.
         */
        passwordRef: string;
        /**
         * Scopes to request for the connector.
         */
        scopes?: string[];
        /**
         * Reference to the secret containing the client secret for the connector.
         */
        secretRef?: string;
        /**
         * Username for the connector.
         */
        username?: string;
        /**
         * Reference to the secret containing the username for the connector.
         */
        usernameRef?: string;
    }

    export interface KubernetesServiceAccount {
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: string;
        /**
         * Reference to the secret containing the service account token for the connector.
         */
        serviceAccountTokenRef: string;
    }

    export interface KubernetesUsernamePassword {
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: string;
        /**
         * Reference to the secret containing the password for the connector.
         */
        passwordRef: string;
        /**
         * Username for the connector.
         */
        username?: string;
        /**
         * Reference to the secret containing the username for the connector.
         */
        usernameRef?: string;
    }

    export interface NexusCredentials {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username?: string;
        /**
         * Reference to a secret containing the username to use for authentication.
         */
        usernameRef?: string;
    }

}

export namespace Service {
    export interface AmiVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface CodedeployVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface EcsVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface HelmVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface KubernetesVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface LambdaVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface SshVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface TanzuVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface WinrmVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

}
