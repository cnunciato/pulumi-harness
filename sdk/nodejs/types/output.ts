// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface EncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface EnvironmentVariableOverride {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * The name of the service
     */
    serviceName?: string;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type: string;
    /**
     * The value of the service variable
     */
    value: string;
}

export interface GetEncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetEnvironmentVariableOverride {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * The name of the service
     */
    serviceName: string;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type: string;
    /**
     * The value of the service variable
     */
    value: string;
}

export interface GetGitConnectorCommitDetail {
    authorEmailId: string;
    authorName: string;
    message: string;
}

export interface GetSecretManagerUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetSshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetTriggerCondition {
    onWebhooks: outputs.GetTriggerConditionOnWebhook[];
    triggerConditionType: string;
}

export interface GetTriggerConditionOnWebhook {
    webhookDetails: outputs.GetTriggerConditionOnWebhookWebhookDetail[];
}

export interface GetTriggerConditionOnWebhookWebhookDetail {
    header: string;
    method: string;
    payload: string;
    webhookToken: string;
    webhookUrl: string;
}

export interface GitConnectorCommitDetails {
    /**
     * The email id of the author
     */
    authorEmailId?: string;
    /**
     * The name of the author
     */
    authorName?: string;
    /**
     * Commit message
     */
    message?: string;
}

export interface GitConnectorUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface InfrastructureDefinitionAwsAmi {
    /**
     * The ami deployment type to use. Valid options are AWS_ASG, SPOTINST
     */
    amiDeploymentType: string;
    /**
     * Flag to indicate whether the autoscaling group identifies the workload.
     */
    asgIdentifiesWorkload?: boolean;
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: string;
    /**
     * The classic load balancers to use.
     */
    classicLoadbalancers?: string[];
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The name of the SpotInst cloud provider to connect with.
     */
    spotinstCloudProviderName?: string;
    /**
     * The SpotInst configuration to use.
     */
    spotinstConfigJson?: string;
    /**
     * The staging classic load balancers to use.
     */
    stageClassicLoadbalancers?: string[];
    /**
     * The staging classic load balancers to use.
     */
    stageTargetGroupArns?: string[];
    /**
     * The ARN's of the target groups.
     */
    targetGroupArns?: string[];
    /**
     * Flag to enable traffic shifting.
     */
    useTrafficShift?: boolean;
}

export interface InfrastructureDefinitionAwsEcs {
    /**
     * Flag to assign a public IP address.
     */
    assignPublicIp?: boolean;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the ECS cluster to use.
     */
    clusterName: string;
    /**
     * The ARN of the role to use for execution.
     */
    executionRole?: string;
    /**
     * The type of launch configuration to use. Valid options are FARGATE
     */
    launchType: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: string[];
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: string[];
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: string;
}

export interface InfrastructureDefinitionAwsLambda {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The IAM role to use.
     */
    iamRole?: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: string[];
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: string[];
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: string;
}

export interface InfrastructureDefinitionAwsSsh {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: string;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The desired capacity of the auto scaling group.
     */
    desiredCapacity?: number;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: string;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: string;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: string;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: string;
    /**
     * The region to deploy to.
     */
    region: string;
    /**
     * The tags to use when selecting the instances.
     */
    tags?: outputs.InfrastructureDefinitionAwsSshTag[];
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcIds?: string[];
}

export interface InfrastructureDefinitionAwsSshTag {
    key: string;
    value: string;
}

export interface InfrastructureDefinitionAwsWinrm {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName: string;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The desired capacity of the autoscaling group.
     */
    desiredCapacity?: number;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName: string;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: string;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: string;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: string;
    /**
     * The region to deploy to.
     */
    region: string;
}

export interface InfrastructureDefinitionAzureVmss {
    /**
     * The type of authentication to use. Valid options are SSH*PUBLIC*KEY.
     */
    authType: string;
    /**
     * Base name.
     */
    baseName: string;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The type of deployment. Valid options are NATIVE_VMSS
     */
    deploymentType: string;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: string;
    /**
     * The name of the resource group.
     */
    resourceGroupName: string;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: string;
    /**
     * The username to connect with.
     */
    username: string;
}

export interface InfrastructureDefinitionAzureWebapp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the resource group.
     */
    resourceGroup: string;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: string;
}

export interface InfrastructureDefinitionCustom {
    /**
     * The template version
     */
    deploymentTypeTemplateVersion: string;
    /**
     * Variables to be used in the service
     */
    variables?: outputs.InfrastructureDefinitionCustomVariable[];
}

export interface InfrastructureDefinitionCustomVariable {
    /**
     * The name of the infrastructure definition
     */
    name: string;
    value: string;
}

export interface InfrastructureDefinitionDatacenterSsh {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the SSH connection attributes to use.
     */
    hostConnectionAttributesName: string;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: string[];
}

export interface InfrastructureDefinitionDatacenterWinrm {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: string[];
    /**
     * The name of the WinRM connection attributes to use.
     */
    winrmConnectionAttributesName: string;
}

export interface InfrastructureDefinitionKubernetes {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: string;
    /**
     * The naming convention of the release. When using Helm Native the default is ${infra.kubernetes.infraId}. For standard Kubernetes manifests the default is release-${infra.kubernetes.infraId}
     */
    releaseName: string;
}

export interface InfrastructureDefinitionKubernetesGcp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The name of the cluster being deployed to.
     */
    clusterName: string;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: string;
    /**
     * The naming convention of the release.
     */
    releaseName: string;
}

export interface InfrastructureDefinitionTanzu {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: string;
    /**
     * The PCF organization to use.
     */
    organization: string;
    /**
     * The PCF space to deploy to.
     */
    space: string;
}

export interface PlatformCcmFiltersFilterProperties {
    /**
     * Type of CCM filters.
     */
    filterType: string;
    /**
     * Tags to associate with the resource. Tags should be in the form `name:value`.
     */
    tags?: string[];
}

export interface SshCredentialKerberosAuthentication {
    /**
     * Port to use for Kerberos authentication
     */
    port: number;
    /**
     * Name of the principal for authentication
     */
    principal: string;
    /**
     * Realm associated with the Kerberos authentication
     */
    realm: string;
    /**
     * TGT generation method
     */
    tgtGenerationMethod?: outputs.SshCredentialKerberosAuthenticationTgtGenerationMethod;
}

export interface SshCredentialKerberosAuthenticationTgtGenerationMethod {
    kerberosPasswordId?: string;
    keyTabFilePath?: string;
}

export interface SshCredentialSshAuthentication {
    /**
     * Inline SSH authentication configuration. Only ond of `passphraseSecretId` or `sshKeyFileId` should be used
     */
    inlineSsh?: outputs.SshCredentialSshAuthenticationInlineSsh;
    /**
     * The port to connect to
     */
    port: number;
    /**
     * Server password authentication configuration
     */
    serverPassword?: outputs.SshCredentialSshAuthenticationServerPassword;
    /**
     * Use ssh key file for authentication
     */
    sshKeyFile?: outputs.SshCredentialSshAuthenticationSshKeyFile;
    /**
     * The username to use when connecting to ssh
     */
    username: string;
}

export interface SshCredentialSshAuthenticationInlineSsh {
    passphraseSecretId?: string;
    sshKeyFileId: string;
}

export interface SshCredentialSshAuthenticationServerPassword {
    passwordSecretId: string;
}

export interface SshCredentialSshAuthenticationSshKeyFile {
    passphraseSecretId?: string;
    path: string;
}

export interface SshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface UserGroupLdapSettings {
    /**
     * The group DN of the LDAP user group.
     */
    groupDn?: string;
    /**
     * The group name of the LDAP user group.
     */
    groupName?: string;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: string;
}

export interface UserGroupNotificationSettings {
    /**
     * The email addresses of the user group.
     */
    groupEmailAddresses?: string[];
    /**
     * The Microsoft Teams webhook URL of the user group.
     */
    microsoftTeamsWebhookUrl?: string;
    /**
     * Indicates whether an email is sent when a new user is added to the group.
     */
    sendMailToNewMembers?: boolean;
    /**
     * Enable this setting to have notifications sent to the members of this group.
     */
    sendNotificationsToMembers?: boolean;
    /**
     * The Slack channel to send notifications to.
     */
    slackChannel?: string;
    /**
     * The Slack webhook URL to send notifications to.
     */
    slackWebhookUrl?: string;
}

export interface UserGroupPermissions {
    /**
     * The account permissions of the user group. Valid options are ADMINISTER*OTHER*ACCOUNT*FUNCTIONS, CREATE*AND*DELETE*APPLICATION, CREATE*CUSTOM*DASHBOARDS, MANAGE*ALERT*NOTIFICATION*RULES, MANAGE*API*KEYS, MANAGE*APPLICATION*STACKS, MANAGE*AUTHENTICATION*SETTINGS, MANAGE*CLOUD*PROVIDERS, MANAGE*CONFIG*AS*CODE, MANAGE*CONNECTORS, MANAGE*CUSTOM*DASHBOARDS, MANAGE*DELEGATE*PROFILES, MANAGE*DELEGATES, MANAGE*DEPLOYMENT*FREEZES, MANAGE*IP*WHITELIST, MANAGE*PIPELINE*GOVERNANCE*STANDARDS, MANAGE*RESTRICTED*ACCESS, MANAGE*SECRET*MANAGERS, MANAGE*SECRETS, MANAGE*SSH*AND*WINRM, MANAGE*TAGS, MANAGE*TEMPLATE*LIBRARY, MANAGE*USER*AND*USER*GROUPS*AND*API*KEYS, MANAGE*USERS*AND*GROUPS, READ*USERS*AND*GROUPS, VIEW*AUDITS, VIEW*USER*AND*USER*GROUPS*AND*API_KEYS
     */
    accountPermissions?: string[];
    /**
     * Application specific permissions
     */
    appPermissions?: outputs.UserGroupPermissionsAppPermissions;
}

export interface UserGroupPermissionsAppPermissions {
    /**
     * The permission to perform actions against all resources.
     */
    alls?: outputs.UserGroupPermissionsAppPermissionsAll[];
    /**
     * Permission configuration to perform actions against deployments.
     */
    deployments?: outputs.UserGroupPermissionsAppPermissionsDeployment[];
    /**
     * Permission configuration to perform actions against workflows.
     */
    environments?: outputs.UserGroupPermissionsAppPermissionsEnvironment[];
    /**
     * Permission configuration to perform actions against pipelines.
     */
    pipelines?: outputs.UserGroupPermissionsAppPermissionsPipeline[];
    /**
     * Permission configuration to perform actions against provisioners.
     */
    provisioners?: outputs.UserGroupPermissionsAppPermissionsProvisioner[];
    /**
     * Permission configuration to perform actions against services.
     */
    services?: outputs.UserGroupPermissionsAppPermissionsService[];
    /**
     * Permission configuration to perform actions against templates.
     */
    templates?: outputs.UserGroupPermissionsAppPermissionsTemplate[];
    /**
     * Permission configuration to perform actions against workflows.
     */
    workflows?: outputs.UserGroupPermissionsAppPermissionsWorkflow[];
}

export interface UserGroupPermissionsAppPermissionsAll {
    actions: string[];
    appIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsDeployment {
    actions: string[];
    appIds?: string[];
    envIds?: string[];
    filters?: string[];
}

export interface UserGroupPermissionsAppPermissionsEnvironment {
    actions: string[];
    appIds?: string[];
    envIds?: string[];
    filters?: string[];
}

export interface UserGroupPermissionsAppPermissionsPipeline {
    actions: string[];
    appIds?: string[];
    envIds?: string[];
    filters?: string[];
}

export interface UserGroupPermissionsAppPermissionsProvisioner {
    actions: string[];
    appIds?: string[];
    provisionerIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsService {
    actions: string[];
    appIds?: string[];
    serviceIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsTemplate {
    actions: string[];
    appIds?: string[];
    templateIds?: string[];
}

export interface UserGroupPermissionsAppPermissionsWorkflow {
    actions: string[];
    appIds?: string[];
    filters?: string[];
}

export interface UserGroupSamlSettings {
    /**
     * The group name of the SAML user group.
     */
    groupName?: string;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: string;
}

export namespace cloudprovider {
    export interface AwsAssumeCrossAccountRole {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: string;
        /**
         * This is an IAM role in the target deployment AWS account.
         */
        roleArn: string;
    }

    export interface AwsUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: string;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: string;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: string;
    }

    export interface DatacenterUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: string;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: string;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: string;
    }

    export interface GcpUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: string;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: string;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: string;
    }

    export interface KubernetesAuthentication {
        /**
         * Delegate selectors to inherit the GCP credentials from.
         */
        delegateSelectors?: string[];
        /**
         * Service account configuration for connecting to the Kubernetes cluster
         */
        oidc?: outputs.cloudprovider.KubernetesAuthenticationOidc;
        /**
         * Username and password for authentication to the cluster
         */
        serviceAccount?: outputs.cloudprovider.KubernetesAuthenticationServiceAccount;
        /**
         * Username and password for authentication to the cluster
         */
        usernamePassword?: outputs.cloudprovider.KubernetesAuthenticationUsernamePassword;
    }

    export interface KubernetesAuthenticationOidc {
        clientIdSecretName: string;
        clientSecretSecretName?: string;
        identityProviderUrl: string;
        masterUrl: string;
        passwordSecretName: string;
        scopes?: string[];
        username: string;
    }

    export interface KubernetesAuthenticationServiceAccount {
        caCertificateSecretName?: string;
        masterUrl: string;
        serviceAccountTokenSecretName: string;
    }

    export interface KubernetesAuthenticationUsernamePassword {
        masterUrl: string;
        passwordSecretName: string;
        username?: string;
        usernameSecretName?: string;
    }

    export interface KubernetesUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: string;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: string;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: string;
    }

}

export namespace platform {
    export interface AppDynamicsConnectorApiToken {
        /**
         * The client id used for connecting to App Dynamics.
         */
        clientId: string;
        /**
         * Reference to the Harness secret containing the App Dynamics client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientSecretRef: string;
    }

    export interface AppDynamicsConnectorUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username: string;
    }

    export interface ArtifactoryConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username?: string;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: string;
    }

    export interface AwsCCConnectorCrossAccountAccess {
        /**
         * The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
         */
        externalId: string;
        /**
         * The ARN of the role to use for cross-account access.
         */
        roleArn: string;
    }

    export interface AwsConnectorCrossAccountAccess {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: string;
        /**
         * The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
         */
        roleArn: string;
    }

    export interface AwsConnectorEqualJitterBackoffStrategy {
        /**
         * Base delay.
         */
        baseDelay?: number;
        /**
         * Max BackOff Time.
         */
        maxBackoffTime?: number;
        /**
         * Retry Count.
         */
        retryCount?: number;
    }

    export interface AwsConnectorFixedDelayBackoffStrategy {
        /**
         * Fixed Backoff.
         */
        fixedBackoff?: number;
        /**
         * Retry Count.
         */
        retryCount?: number;
    }

    export interface AwsConnectorFullJitterBackoffStrategy {
        /**
         * Base delay.
         */
        baseDelay?: number;
        /**
         * Max BackOff Time.
         */
        maxBackoffTime?: number;
        /**
         * Retry Count.
         */
        retryCount?: number;
    }

    export interface AwsConnectorInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: string[];
    }

    export interface AwsConnectorIrsa {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: string[];
    }

    export interface AwsConnectorManual {
        /**
         * AWS access key.
         */
        accessKey?: string;
        /**
         * Reference to the Harness secret containing the aws access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        accessKeyRef?: string;
        /**
         * Connect only use delegates with these tags.
         */
        delegateSelectors?: string[];
        /**
         * Reference to the Harness secret containing the aws secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        secretKeyRef: string;
    }

    export interface AwsKmsConnectorCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: outputs.platform.AwsKmsConnectorCredentialsAssumeRole;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: boolean;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: outputs.platform.AwsKmsConnectorCredentialsManual;
    }

    export interface AwsKmsConnectorCredentialsAssumeRole {
        duration: number;
        externalId?: string;
        roleArn: string;
    }

    export interface AwsKmsConnectorCredentialsManual {
        accessKeyRef: string;
        secretKeyRef: string;
    }

    export interface AwsSecretManagerConnectorCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: outputs.platform.AwsSecretManagerConnectorCredentialsAssumeRole;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: boolean;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: outputs.platform.AwsSecretManagerConnectorCredentialsManual;
    }

    export interface AwsSecretManagerConnectorCredentialsAssumeRole {
        duration: number;
        externalId?: string;
        roleArn: string;
    }

    export interface AwsSecretManagerConnectorCredentialsManual {
        accessKeyRef: string;
        secretKeyRef: string;
    }

    export interface AzureCloudCostConnectorBillingExportSpec {
        /**
         * Name of the container.
         */
        containerName: string;
        /**
         * Name of the directory.
         */
        directoryName: string;
        /**
         * Name of the report.
         */
        reportName: string;
        /**
         * Name of the storage account.
         */
        storageAccountName: string;
        /**
         * Subsription Id.
         */
        subscriptionId: string;
    }

    export interface AzureCloudProviderConnectorCredentials {
        /**
         * Authenticate to Azure Cloud Provider using details inheriting from delegate.
         */
        azureInheritFromDelegateDetails?: outputs.platform.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetails;
        /**
         * Authenticate to Azure Cloud Provider using manual details.
         */
        azureManualDetails?: outputs.platform.AzureCloudProviderConnectorCredentialsAzureManualDetails;
        /**
         * Type can either be InheritFromDelegate or ManualConfig.
         */
        type: string;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetails {
        auth?: outputs.platform.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuth;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuth {
        azureMsiAuthUa?: outputs.platform.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa;
        type: string;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa {
        clientId?: string;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureManualDetails {
        applicationId?: string;
        auth?: outputs.platform.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuth;
        tenantId?: string;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureManualDetailsAuth {
        azureClientKeyCert?: outputs.platform.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCert;
        azureClientSecretKey?: outputs.platform.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKey;
        type?: string;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCert {
        certificateRef?: string;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKey {
        secretRef?: string;
    }

    export interface BitbucketConnectorApiAuthentication {
        /**
         * Personal access token for interacting with the BitBucket api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        tokenRef: string;
        /**
         * The username used for connecting to the api.
         */
        username?: string;
        /**
         * The name of the Harness secret containing the username. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: string;
    }

    export interface BitbucketConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: outputs.platform.BitbucketConnectorCredentialsHttp;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: outputs.platform.BitbucketConnectorCredentialsSsh;
    }

    export interface BitbucketConnectorCredentialsHttp {
        passwordRef?: string;
        username?: string;
        usernameRef?: string;
    }

    export interface BitbucketConnectorCredentialsSsh {
        sshKeyRef: string;
    }

    export interface DockerConnectorCredentials {
        /**
         * The reference to the Harness secret containing the password to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * The username to use for the docker registry.
         */
        username?: string;
        /**
         * The reference to the Harness secret containing the username to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: string;
    }

    export interface ElasticsearchConnectorApiToken {
        /**
         * The client id used for connecting to ElasticSearch.
         */
        clientId: string;
        /**
         * Reference to the Harness secret containing the ElasticSearch client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientSecretRef: string;
    }

    export interface ElasticsearchConnectorNoAuthentication {
    }

    export interface ElasticsearchConnectorUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username: string;
    }

    export interface EnvironmentClustersMappingCluster {
        /**
         * account Identifier of the account
         */
        identifier?: string;
        /**
         * name of the cluster
         */
        name?: string;
        /**
         * scope at which the cluster exists in harness gitops, project vs org vs account
         */
        scope?: string;
    }

    export interface FeatureFlagGitDetails {
        /**
         * The commit message to use as part of a gitsync operation
         */
        commitMsg: string;
    }

    export interface FeatureFlagVariation {
        /**
         * The description of the variation
         */
        description: string;
        /**
         * The identifier of the variation
         */
        identifier: string;
        /**
         * The user friendly name of the variation
         */
        name: string;
        /**
         * The value of the variation
         */
        value: string;
    }

    export interface FiltersFilterProperties {
        /**
         * Corresponding Entity of the filter. Currently supported types are {Connector, DelegateProfile, Delegate, EnvironmentGroup, FileStore, Environment}.
         */
        filterType: string;
        /**
         * Tags to associate with the resource. Tags should be in the form `name:value`.
         */
        tags?: string[];
    }

    export interface GcpCloudCostConnectorBillingExportSpec {
        /**
         * Data Set Id.
         */
        dataSetId: string;
        /**
         * Table Id.
         */
        tableId: string;
    }

    export interface GcpConnectorInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: string[];
    }

    export interface GcpConnectorManual {
        /**
         * The delegates to connect with.
         */
        delegateSelectors: string[];
        /**
         * Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        secretKeyRef: string;
    }

    export interface GetAppDynamicsConnectorApiToken {
        clientId: string;
        clientSecretRef: string;
    }

    export interface GetAppDynamicsConnectorUsernamePassword {
        passwordRef: string;
        username: string;
    }

    export interface GetArtifactoryConnectorCredential {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetAwsCCConnectorCrossAccountAccess {
        externalId: string;
        roleArn: string;
    }

    export interface GetAwsConnectorCrossAccountAccess {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId: string;
        /**
         * The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
         */
        roleArn: string;
    }

    export interface GetAwsConnectorEqualJitterBackoffStrategy {
        /**
         * Base delay.
         */
        baseDelay: number;
        /**
         * Max BackOff Time.
         */
        maxBackoffTime: number;
        /**
         * Retry Count.
         */
        retryCount: number;
    }

    export interface GetAwsConnectorFixedDelayBackoffStrategy {
        /**
         * Fixed Backoff.
         */
        fixedBackoff: number;
        /**
         * Retry Count.
         */
        retryCount: number;
    }

    export interface GetAwsConnectorFullJitterBackoffStrategy {
        /**
         * Base delay.
         */
        baseDelay: number;
        /**
         * Max BackOff Time.
         */
        maxBackoffTime: number;
        /**
         * Retry Count.
         */
        retryCount: number;
    }

    export interface GetAwsConnectorInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: string[];
    }

    export interface GetAwsConnectorIrsa {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: string[];
    }

    export interface GetAwsConnectorManual {
        /**
         * AWS access key.
         */
        accessKey: string;
        /**
         * Reference to the Harness secret containing the aws access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        accessKeyRef: string;
        /**
         * Connect only use delegates with these tags.
         */
        delegateSelectors: string[];
        /**
         * Reference to the Harness secret containing the aws secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        secretKeyRef: string;
    }

    export interface GetAwsKmsConnectorCredential {
        assumeRoles: outputs.platform.GetAwsKmsConnectorCredentialAssumeRole[];
        inheritFromDelegate: boolean;
        manuals: outputs.platform.GetAwsKmsConnectorCredentialManual[];
    }

    export interface GetAwsKmsConnectorCredentialAssumeRole {
        duration: number;
        externalId: string;
        roleArn: string;
    }

    export interface GetAwsKmsConnectorCredentialManual {
        accessKeyRef: string;
        secretKeyRef: string;
    }

    export interface GetAwsSecretManagerConnectorCredential {
        assumeRoles: outputs.platform.GetAwsSecretManagerConnectorCredentialAssumeRole[];
        inheritFromDelegate: boolean;
        manuals: outputs.platform.GetAwsSecretManagerConnectorCredentialManual[];
    }

    export interface GetAwsSecretManagerConnectorCredentialAssumeRole {
        duration: number;
        externalId: string;
        roleArn: string;
    }

    export interface GetAwsSecretManagerConnectorCredentialManual {
        accessKeyRef: string;
        secretKeyRef: string;
    }

    export interface GetAzureCloudCostConnectorBillingExportSpec {
        containerName: string;
        directoryName: string;
        reportName: string;
        storageAccountName: string;
        /**
         * Subsription id.
         */
        subscriptionId: string;
    }

    export interface GetAzureCloudProviderConnectorCredential {
        azureInheritFromDelegateDetails: outputs.platform.GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetail[];
        azureManualDetails: outputs.platform.GetAzureCloudProviderConnectorCredentialAzureManualDetail[];
        type: string;
    }

    export interface GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetail {
        auths: outputs.platform.GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuth[];
    }

    export interface GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuth {
        azureMsiAuthUas: outputs.platform.GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuthAzureMsiAuthUa[];
        type: string;
    }

    export interface GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuthAzureMsiAuthUa {
        clientId: string;
    }

    export interface GetAzureCloudProviderConnectorCredentialAzureManualDetail {
        applicationId: string;
        auths: outputs.platform.GetAzureCloudProviderConnectorCredentialAzureManualDetailAuth[];
        tenantId: string;
    }

    export interface GetAzureCloudProviderConnectorCredentialAzureManualDetailAuth {
        azureClientKeyCerts: outputs.platform.GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientKeyCert[];
        azureClientSecretKeys: outputs.platform.GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientSecretKey[];
        type: string;
    }

    export interface GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientKeyCert {
        certificateRef: string;
    }

    export interface GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientSecretKey {
        secretRef: string;
    }

    export interface GetBitbucketConnectorApiAuthentication {
        tokenRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetBitbucketConnectorCredential {
        https: outputs.platform.GetBitbucketConnectorCredentialHttp[];
        sshes: outputs.platform.GetBitbucketConnectorCredentialSsh[];
    }

    export interface GetBitbucketConnectorCredentialHttp {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetBitbucketConnectorCredentialSsh {
        sshKeyRef: string;
    }

    export interface GetCcmFiltersFilterProperty {
        filterType: string;
        tags: string[];
    }

    export interface GetDockerConnectorCredential {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetElasticsearchConnectorApiToken {
        /**
         * The client id used for connecting to ElasticSearch.
         */
        clientId: string;
        /**
         * Reference to the Harness secret containing the ElasticSearch client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientSecretRef: string;
    }

    export interface GetElasticsearchConnectorUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username: string;
    }

    export interface GetFiltersFilterProperty {
        filterType: string;
        tags: string[];
    }

    export interface GetGcpCloudCostConnectorBillingExportSpec {
        dataSetId: string;
        tableId: string;
    }

    export interface GetGcpConnectorInheritFromDelegate {
        delegateSelectors: string[];
    }

    export interface GetGcpConnectorManual {
        delegateSelectors: string[];
        secretKeyRef: string;
    }

    export interface GetGitConnectorCredential {
        https: outputs.platform.GetGitConnectorCredentialHttp[];
        sshes: outputs.platform.GetGitConnectorCredentialSsh[];
    }

    export interface GetGitConnectorCredentialHttp {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetGitConnectorCredentialSsh {
        sshKeyRef: string;
    }

    export interface GetGithubConnectorApiAuthentication {
        githubApps: outputs.platform.GetGithubConnectorApiAuthenticationGithubApp[];
        tokenRef: string;
    }

    export interface GetGithubConnectorApiAuthenticationGithubApp {
        applicationId: string;
        applicationIdRef: string;
        installationId: string;
        installationIdRef: string;
        privateKeyRef: string;
    }

    export interface GetGithubConnectorCredential {
        https: outputs.platform.GetGithubConnectorCredentialHttp[];
        sshes: outputs.platform.GetGithubConnectorCredentialSsh[];
    }

    export interface GetGithubConnectorCredentialHttp {
        tokenRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetGithubConnectorCredentialSsh {
        sshKeyRef: string;
    }

    export interface GetGitlabConnectorApiAuthentication {
        tokenRef: string;
    }

    export interface GetGitlabConnectorCredential {
        https: outputs.platform.GetGitlabConnectorCredentialHttp[];
        sshes: outputs.platform.GetGitlabConnectorCredentialSsh[];
    }

    export interface GetGitlabConnectorCredentialHttp {
        passwordRef: string;
        tokenRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetGitlabConnectorCredentialSsh {
        sshKeyRef: string;
    }

    export interface GetGitopsAgentMetadata {
        highAvailability: boolean;
        namespace: string;
    }

    export interface GetGitopsApplicationsApplication {
        /**
         * Metadata corresponding to the resources. This includes all the objects a user must create.
         */
        metadatas?: outputs.platform.GetGitopsApplicationsApplicationMetadata[];
        /**
         * Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
         */
        specs?: outputs.platform.GetGitopsApplicationsApplicationSpec[];
    }

    export interface GetGitopsApplicationsApplicationMetadata {
        annotations: {[key: string]: string};
        clusterName?: string;
        finalizers: string[];
        generateName?: string;
        generation: string;
        labels: {[key: string]: string};
        /**
         * Name of the GitOps application.
         */
        name?: string;
        namespace: string;
        ownerReferences?: outputs.platform.GetGitopsApplicationsApplicationMetadataOwnerReference[];
        uid: string;
    }

    export interface GetGitopsApplicationsApplicationMetadataOwnerReference {
        apiVersion?: string;
        blockOwnerDeletion?: boolean;
        controller?: boolean;
        /**
         * Kind of the GitOps application.
         */
        kind?: string;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        uid?: string;
    }

    export interface GetGitopsApplicationsApplicationSpec {
        destinations?: outputs.platform.GetGitopsApplicationsApplicationSpecDestination[];
        sources?: outputs.platform.GetGitopsApplicationsApplicationSpecSource[];
        syncPolicies?: outputs.platform.GetGitopsApplicationsApplicationSpecSyncPolicy[];
    }

    export interface GetGitopsApplicationsApplicationSpecDestination {
        /**
         * Name of the GitOps application.
         */
        name?: string;
        namespace?: string;
        server?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSource {
        chart?: string;
        directories?: outputs.platform.GetGitopsApplicationsApplicationSpecSourceDirectory[];
        helms?: outputs.platform.GetGitopsApplicationsApplicationSpecSourceHelm[];
        ksonnets?: outputs.platform.GetGitopsApplicationsApplicationSpecSourceKsonnet[];
        kustomizes?: outputs.platform.GetGitopsApplicationsApplicationSpecSourceKustomize[];
        path?: string;
        plugins?: outputs.platform.GetGitopsApplicationsApplicationSpecSourcePlugin[];
        repoUrl?: string;
        targetRevision?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceDirectory {
        exclude?: string;
        include?: string;
        jsonnets?: outputs.platform.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnet[];
        recurse?: boolean;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnet {
        extVars?: outputs.platform.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar[];
        libs?: string[];
        tlas?: outputs.platform.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTla[];
    }

    export interface GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar {
        code?: boolean;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTla {
        code?: boolean;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceHelm {
        fileParameters?: outputs.platform.GetGitopsApplicationsApplicationSpecSourceHelmFileParameter[];
        parameters?: outputs.platform.GetGitopsApplicationsApplicationSpecSourceHelmParameter[];
        passCredentials?: boolean;
        releaseName?: string;
        valueFiles?: string[];
        values?: string;
        version?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceHelmFileParameter {
        /**
         * Name of the GitOps application.
         */
        name?: string;
        path?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceHelmParameter {
        forceString?: boolean;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceKsonnet {
        environment?: string;
        parameters?: outputs.platform.GetGitopsApplicationsApplicationSpecSourceKsonnetParameter[];
    }

    export interface GetGitopsApplicationsApplicationSpecSourceKsonnetParameter {
        component?: string;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceKustomize {
        commonAnnotations?: {[key: string]: string};
        commonLabels?: {[key: string]: string};
        forceCommonAnnotations?: boolean;
        forceCommonLabels?: boolean;
        images?: string[];
        namePrefix?: string;
        nameSuffix?: string;
        version?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourcePlugin {
        envs?: outputs.platform.GetGitopsApplicationsApplicationSpecSourcePluginEnv[];
        /**
         * Name of the GitOps application.
         */
        name?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourcePluginEnv {
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSyncPolicy {
        automateds?: outputs.platform.GetGitopsApplicationsApplicationSpecSyncPolicyAutomated[];
        retries?: outputs.platform.GetGitopsApplicationsApplicationSpecSyncPolicyRetry[];
        syncOptions?: string[];
    }

    export interface GetGitopsApplicationsApplicationSpecSyncPolicyAutomated {
        allowEmpty?: boolean;
        prune?: boolean;
        selfHeal?: boolean;
    }

    export interface GetGitopsApplicationsApplicationSpecSyncPolicyRetry {
        backoffs?: outputs.platform.GetGitopsApplicationsApplicationSpecSyncPolicyRetryBackoff[];
        limit?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSyncPolicyRetryBackoff {
        duration?: string;
        factor?: string;
        maxDuration?: string;
    }

    export interface GetGitopsClusterQuery {
        /**
         * Cluster server URL or the cluster name.
         */
        ids?: outputs.platform.GetGitopsClusterQueryId[];
        /**
         * Name of the GitOps cluster.
         */
        name?: string;
        /**
         * Server of the GitOps cluster.
         */
        server?: string;
    }

    export interface GetGitopsClusterQueryId {
        type?: string;
        value?: string;
    }

    export interface GetGitopsClusterRequest {
        clusters?: outputs.platform.GetGitopsClusterRequestCluster[];
        /**
         * The ID of this resource.
         */
        ids?: outputs.platform.GetGitopsClusterRequestId[];
        tags: string[];
        updateMasks?: outputs.platform.GetGitopsClusterRequestUpdateMask[];
        updatedFields?: string[];
        upsert?: boolean;
    }

    export interface GetGitopsClusterRequestCluster {
        annotations?: {[key: string]: string};
        clusterResources?: boolean;
        configs?: outputs.platform.GetGitopsClusterRequestClusterConfig[];
        infos: outputs.platform.GetGitopsClusterRequestClusterInfo[];
        labels?: {[key: string]: string};
        name?: string;
        namespaces?: string[];
        project?: string;
        refreshRequestedAts?: outputs.platform.GetGitopsClusterRequestClusterRefreshRequestedAt[];
        server?: string;
        shard?: string;
    }

    export interface GetGitopsClusterRequestClusterConfig {
        awsAuthConfigs?: outputs.platform.GetGitopsClusterRequestClusterConfigAwsAuthConfig[];
        bearerToken?: string;
        clusterConnectionType?: string;
        execProviderConfigs?: outputs.platform.GetGitopsClusterRequestClusterConfigExecProviderConfig[];
        password?: string;
        tlsClientConfigs?: outputs.platform.GetGitopsClusterRequestClusterConfigTlsClientConfig[];
        username?: string;
    }

    export interface GetGitopsClusterRequestClusterConfigAwsAuthConfig {
        clusterName?: string;
        roleARN?: string;
    }

    export interface GetGitopsClusterRequestClusterConfigExecProviderConfig {
        apiVersion?: string;
        args?: string[];
        command?: string;
        env?: {[key: string]: string};
        installHint?: string;
    }

    export interface GetGitopsClusterRequestClusterConfigTlsClientConfig {
        caData?: string;
        certData?: string;
        insecure?: boolean;
        keyData?: string;
        serverName?: string;
    }

    export interface GetGitopsClusterRequestClusterInfo {
        apiVersions?: string[];
        applicationsCount?: string;
        cacheInfos: outputs.platform.GetGitopsClusterRequestClusterInfoCacheInfo[];
        connectionStates: outputs.platform.GetGitopsClusterRequestClusterInfoConnectionState[];
        serverVersion: string;
    }

    export interface GetGitopsClusterRequestClusterInfoCacheInfo {
        apisCount?: string;
        lastCacheSyncTime?: string;
        resourcesCount?: string;
    }

    export interface GetGitopsClusterRequestClusterInfoConnectionState {
        attemptedAts?: outputs.platform.GetGitopsClusterRequestClusterInfoConnectionStateAttemptedAt[];
        message: string;
        status: string;
    }

    export interface GetGitopsClusterRequestClusterInfoConnectionStateAttemptedAt {
        nanos?: number;
        seconds?: string;
    }

    export interface GetGitopsClusterRequestClusterRefreshRequestedAt {
        nanos?: number;
        seconds?: string;
    }

    export interface GetGitopsClusterRequestId {
        type?: string;
        value?: string;
    }

    export interface GetGitopsClusterRequestUpdateMask {
        paths?: any[][];
    }

    export interface GetGitopsGnupgRequest {
        /**
         * Public key details.
         */
        publickeys?: outputs.platform.GetGitopsGnupgRequestPublickey[];
        /**
         * Indicates if the GnuPG Key should be inserted if not present or updated if present.
         */
        upsert?: boolean;
    }

    export interface GetGitopsGnupgRequestPublickey {
        fingerprint?: string;
        keyData?: string;
        keyId?: string;
        owner?: string;
        subType?: string;
        trust?: string;
    }

    export interface GetGitopsRepoCredCred {
        /**
         * Specifies whether helm-oci support should be enabled for this repo.
         */
        enableOci?: boolean;
        /**
         * Specifies the GitHub API URL for GitHub app authentication.
         */
        githubAppEnterpriseBaseUrl?: string;
        /**
         * Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
         */
        githubAppId?: string;
        /**
         * Specifies the ID of the installed GitHub App for GitHub app authentication.
         */
        githubAppInstallationId?: string;
        /**
         * github*app*private_key specifies the private key PEM data for authentication via GitHub app.
         */
        githubAppPrivateKey?: string;
        /**
         * Password for authenticating at the repo server.
         */
        password?: string;
        /**
         * Contains the private key data for authenticating at the repo server using SSH (only Git repos).
         */
        sshPrivateKey?: string;
        /**
         * Specifies the TLS client cert data for authenticating at the repo server.
         */
        tlsClientCertData?: string;
        /**
         * Specifies the TLS client cert key for authenticating at the repo server.
         */
        tlsClientCertKey?: string;
        /**
         * Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
         */
        type?: string;
        /**
         * url representing this object.
         */
        url?: string;
        /**
         * Username for authenticating at the repo server.
         */
        username?: string;
    }

    export interface GetGitopsRepositoryRepo {
        connectionType?: string;
        enableLfs?: boolean;
        enableOci?: boolean;
        githubAppEnterpriseBaseUrl?: string;
        githubAppId?: string;
        githubAppInstallationId?: string;
        githubAppPrivateKey?: string;
        inheritedCreds?: boolean;
        insecure?: boolean;
        insecureIgnoreHostKey?: boolean;
        name?: string;
        password?: string;
        project: string;
        proxy?: string;
        /**
         * Repo details holding application configurations.
         */
        repo?: string;
        sshPrivateKey?: string;
        tlsClientCertData?: string;
        tlsClientCertKey?: string;
        type_: string;
        username?: string;
    }

    export interface GetGitopsRepositoryUpdateMask {
        /**
         * The set of field mask paths.
         */
        paths?: string[];
    }

    export interface GetHelmConnectorCredential {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetInputSetGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch: string;
        /**
         * Name of the branch.
         */
        branchName: string;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage: string;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity.
         */
        connectorRef: string;
        /**
         * File path of the Entity in the repository.
         */
        filePath: string;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId: string;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId: string;
        /**
         * Connector reference for Parent Entity (Pipeline).
         */
        parentEntityConnectorRef: string;
        /**
         * Repository name for Parent Entity (Pipeline).
         */
        parentEntityRepoName: string;
        /**
         * Name of the repository.
         */
        repoName: string;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType: string;
    }

    export interface GetJenkinsConnectorAuth {
        jenkinsBearerTokens: outputs.platform.GetJenkinsConnectorAuthJenkinsBearerToken[];
        jenkinsUserNamePasswords: outputs.platform.GetJenkinsConnectorAuthJenkinsUserNamePassword[];
        type: string;
    }

    export interface GetJenkinsConnectorAuthJenkinsBearerToken {
        tokenRef: string;
    }

    export interface GetJenkinsConnectorAuthJenkinsUserNamePassword {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetJiraConnectorAuth {
        authType: string;
        usernamePasswords: outputs.platform.GetJiraConnectorAuthUsernamePassword[];
    }

    export interface GetJiraConnectorAuthUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username: string;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef: string;
    }

    export interface GetKubernetesConnectorClientKeyCert {
        caCertRef: string;
        clientCertRef: string;
        clientKeyAlgorithm: string;
        clientKeyPassphraseRef: string;
        clientKeyRef: string;
        masterUrl: string;
    }

    export interface GetKubernetesConnectorInheritFromDelegate {
        /**
         * Selectors to use for the delegate.
         */
        delegateSelectors: string[];
    }

    export interface GetKubernetesConnectorOpenidConnect {
        clientIdRef: string;
        issuerUrl: string;
        masterUrl: string;
        passwordRef: string;
        scopes: string[];
        secretRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetKubernetesConnectorServiceAccount {
        masterUrl: string;
        serviceAccountTokenRef: string;
    }

    export interface GetKubernetesConnectorUsernamePassword {
        masterUrl: string;
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetManualFreezeCurrentOrUpcomingWindow {
        /**
         * End time of the freeze
         */
        endTime: number;
        /**
         * Start time of the freeze
         */
        startTime: number;
    }

    export interface GetManualFreezeFreezeWindow {
        /**
         * Duration of the freeze
         */
        duration: string;
        /**
         * End time of the freeze
         */
        endTime: string;
        recurrences: outputs.platform.GetManualFreezeFreezeWindowRecurrence[];
        /**
         * Start time of the freeze
         */
        startTime: string;
        /**
         * Timezone
         */
        timeZone: string;
    }

    export interface GetManualFreezeFreezeWindowRecurrence {
        recurrenceSpecs: outputs.platform.GetManualFreezeFreezeWindowRecurrenceRecurrenceSpec[];
        /**
         * Type of freeze
         */
        type: string;
    }

    export interface GetManualFreezeFreezeWindowRecurrenceRecurrenceSpec {
        until: string;
        value: number;
    }

    export interface GetNexusConnectorCredential {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetOciHelmConnectorCredential {
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetPermissionsPermission {
        action: string;
        allowedScopeLevels: string[];
        identifier: string;
        includeInAllRoles: boolean;
        name: string;
        resourceType: string;
        status: string;
    }

    export interface GetPipelineFiltersFilterProperty {
        filterType: string;
        tags: string[];
    }

    export interface GetPipelineGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch: string;
        /**
         * Name of the branch.
         */
        branchName: string;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage: string;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity.
         */
        connectorRef: string;
        /**
         * File path of the Entity in the repository.
         */
        filePath: string;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId: string;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId: string;
        /**
         * Name of the repository.
         */
        repoName: string;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType: string;
    }

    export interface GetPolicySetPolicy {
        /**
         * Account Identifier of the account
         */
        identifier: string;
        /**
         * Policy failure response - 'warning' for continuation, 'error' for exit
         */
        severity: string;
    }

    export interface GetPrometheusConnectorHeader {
        encryptedValueRef: string;
        key: string;
        value: string;
        valueEncrypted: boolean;
    }

    export interface GetResourceGroupIncludedScope {
        /**
         * Account Identifier of the account
         */
        accountId: string;
        filter: string;
        /**
         * Unique identifier of the organization.
         */
        orgId: string;
        /**
         * Unique identifier of the project.
         */
        projectId: string;
    }

    export interface GetResourceGroupResourceFilter {
        includeAllResources: boolean;
        resources: outputs.platform.GetResourceGroupResourceFilterResource[];
    }

    export interface GetResourceGroupResourceFilterResource {
        attributeFilters: outputs.platform.GetResourceGroupResourceFilterResourceAttributeFilter[];
        identifiers: string[];
        resourceType: string;
    }

    export interface GetResourceGroupResourceFilterResourceAttributeFilter {
        attributeName: string;
        attributeValues: string[];
    }

    export interface GetRoleAssignmentsPrincipal {
        /**
         * Identifier for role assignment.
         */
        identifier: string;
        scopeLevel: string;
        type: string;
    }

    export interface GetSecretSshkeyKerbero {
        principal: string;
        realm: string;
        tgtGenerationMethod: string;
        tgtKeyTabFilePathSpecs: outputs.platform.GetSecretSshkeyKerberoTgtKeyTabFilePathSpec[];
        tgtPasswordSpecs: outputs.platform.GetSecretSshkeyKerberoTgtPasswordSpec[];
    }

    export interface GetSecretSshkeyKerberoTgtKeyTabFilePathSpec {
        keyPath: string;
    }

    export interface GetSecretSshkeyKerberoTgtPasswordSpec {
        password: string;
    }

    export interface GetSecretSshkeySsh {
        credentialType: string;
        sshPasswordCredentials: outputs.platform.GetSecretSshkeySshSshPasswordCredential[];
        sshkeyPathCredentials: outputs.platform.GetSecretSshkeySshSshkeyPathCredential[];
        sshkeyReferenceCredentials: outputs.platform.GetSecretSshkeySshSshkeyReferenceCredential[];
    }

    export interface GetSecretSshkeySshSshPasswordCredential {
        password: string;
        userName: string;
    }

    export interface GetSecretSshkeySshSshkeyPathCredential {
        encryptedPassphrase: string;
        keyPath: string;
        userName: string;
    }

    export interface GetSecretSshkeySshSshkeyReferenceCredential {
        encryptedAssphrase: string;
        key: string;
        userName: string;
    }

    export interface GetServiceNowConnectorAuth {
        adfs: outputs.platform.GetServiceNowConnectorAuthAdf[];
        authType: string;
        usernamePasswords: outputs.platform.GetServiceNowConnectorAuthUsernamePassword[];
    }

    export interface GetServiceNowConnectorAuthAdf {
        adfsUrl: string;
        certificateRef: string;
        clientIdRef: string;
        privateKeyRef: string;
        resourceIdRef: string;
    }

    export interface GetServiceNowConnectorAuthUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username: string;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef: string;
    }

    export interface GetSpotConnectorPermanentToken {
        apiTokenRef: string;
        delegateSelectors: string[];
        executeOnDelegate: boolean;
        spotAccountId: string;
        spotAccountIdRef: string;
    }

    export interface GetTasConnectorCredential {
        tasManualDetails: outputs.platform.GetTasConnectorCredentialTasManualDetail[];
        type: string;
    }

    export interface GetTasConnectorCredentialTasManualDetail {
        endpointUrl: string;
        passwordRef: string;
        username: string;
        usernameRef: string;
    }

    export interface GetTemplateFiltersFilterProperty {
        filterType: string;
        tags: string[];
    }

    export interface GetTemplateGitDetails {
        /**
         * Name of the branch.
         */
        branchName?: string;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: string;
        /**
         * File url of the Entity in the repository.
         */
        fileUrl?: string;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId: string;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId: string;
        /**
         * Name of the repository.
         */
        repoName?: string;
        /**
         * Repo url of the Entity in the repository.
         */
        repoUrl?: string;
    }

    export interface GetTerraformCloudConnectorCredential {
        apiTokens: outputs.platform.GetTerraformCloudConnectorCredentialApiToken[];
    }

    export interface GetTerraformCloudConnectorCredentialApiToken {
        apiTokenRef: string;
    }

    export interface GetUsergroupNotificationConfig {
        /**
         * Group email.
         */
        groupEmail: string;
        /**
         * Url of Microsoft teams webhook.
         */
        microsoftTeamsWebhookUrl: string;
        /**
         * Pager duty key.
         */
        pagerDutyKey: string;
        /**
         * Send email to all the group members.
         */
        sendEmailToAllUsers: boolean;
        /**
         * Url of slack webhook.
         */
        slackWebhookUrl: string;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
         */
        type: string;
    }

    export interface GetVariablesSpec {
        fixedValue: string;
        valueType: string;
    }

    export interface GitConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: outputs.platform.GitConnectorCredentialsHttp;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: outputs.platform.GitConnectorCredentialsSsh;
    }

    export interface GitConnectorCredentialsHttp {
        passwordRef: string;
        username?: string;
        usernameRef?: string;
    }

    export interface GitConnectorCredentialsSsh {
        sshKeyRef: string;
    }

    export interface GitOpsAgentMetadata {
        /**
         * Indicates if the deployment should be deployed using the deploy-ha.yaml
         */
        highAvailability?: boolean;
        /**
         * The k8s namespace that this agent resides in.
         */
        namespace?: string;
    }

    export interface GitOpsApplicationsApplication {
        /**
         * Metadata corresponding to the resources. This includes all the objects a user must create.
         */
        metadatas: outputs.platform.GitOpsApplicationsApplicationMetadata[];
        /**
         * Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
         */
        specs?: outputs.platform.GitOpsApplicationsApplicationSpec[];
    }

    export interface GitOpsApplicationsApplicationMetadata {
        annotations: {[key: string]: string};
        clusterName?: string;
        finalizers: string[];
        generateName?: string;
        generation: string;
        labels: {[key: string]: string};
        /**
         * Name of the GitOps application.
         */
        name?: string;
        namespace: string;
        ownerReferences?: outputs.platform.GitOpsApplicationsApplicationMetadataOwnerReference[];
        uid: string;
    }

    export interface GitOpsApplicationsApplicationMetadataOwnerReference {
        apiVersion?: string;
        blockOwnerDeletion?: boolean;
        controller?: boolean;
        /**
         * Kind of the GitOps application.
         */
        kind?: string;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        uid?: string;
    }

    export interface GitOpsApplicationsApplicationSpec {
        destinations?: outputs.platform.GitOpsApplicationsApplicationSpecDestination[];
        sources?: outputs.platform.GitOpsApplicationsApplicationSpecSource[];
        syncPolicies?: outputs.platform.GitOpsApplicationsApplicationSpecSyncPolicy[];
    }

    export interface GitOpsApplicationsApplicationSpecDestination {
        /**
         * Name of the GitOps application.
         */
        name?: string;
        namespace?: string;
        server?: string;
    }

    export interface GitOpsApplicationsApplicationSpecSource {
        chart?: string;
        directories?: outputs.platform.GitOpsApplicationsApplicationSpecSourceDirectory[];
        helms?: outputs.platform.GitOpsApplicationsApplicationSpecSourceHelm[];
        ksonnets?: outputs.platform.GitOpsApplicationsApplicationSpecSourceKsonnet[];
        kustomizes?: outputs.platform.GitOpsApplicationsApplicationSpecSourceKustomize[];
        path: string;
        plugins?: outputs.platform.GitOpsApplicationsApplicationSpecSourcePlugin[];
        repoUrl: string;
        targetRevision: string;
    }

    export interface GitOpsApplicationsApplicationSpecSourceDirectory {
        exclude?: string;
        include?: string;
        jsonnets?: outputs.platform.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnet[];
        recurse?: boolean;
    }

    export interface GitOpsApplicationsApplicationSpecSourceDirectoryJsonnet {
        extVars?: outputs.platform.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar[];
        libs?: string[];
        tlas?: outputs.platform.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTla[];
    }

    export interface GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar {
        code?: boolean;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTla {
        code?: boolean;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GitOpsApplicationsApplicationSpecSourceHelm {
        fileParameters?: outputs.platform.GitOpsApplicationsApplicationSpecSourceHelmFileParameter[];
        parameters?: outputs.platform.GitOpsApplicationsApplicationSpecSourceHelmParameter[];
        passCredentials?: boolean;
        releaseName?: string;
        valueFiles?: string[];
        values?: string;
        version?: string;
    }

    export interface GitOpsApplicationsApplicationSpecSourceHelmFileParameter {
        /**
         * Name of the GitOps application.
         */
        name?: string;
        path?: string;
    }

    export interface GitOpsApplicationsApplicationSpecSourceHelmParameter {
        forceString?: boolean;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GitOpsApplicationsApplicationSpecSourceKsonnet {
        environment?: string;
        parameters?: outputs.platform.GitOpsApplicationsApplicationSpecSourceKsonnetParameter[];
    }

    export interface GitOpsApplicationsApplicationSpecSourceKsonnetParameter {
        component?: string;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GitOpsApplicationsApplicationSpecSourceKustomize {
        commonAnnotations?: {[key: string]: string};
        commonLabels?: {[key: string]: string};
        forceCommonAnnotations?: boolean;
        forceCommonLabels?: boolean;
        images?: string[];
        namePrefix?: string;
        nameSuffix?: string;
        version?: string;
    }

    export interface GitOpsApplicationsApplicationSpecSourcePlugin {
        envs?: outputs.platform.GitOpsApplicationsApplicationSpecSourcePluginEnv[];
        /**
         * Name of the GitOps application.
         */
        name?: string;
    }

    export interface GitOpsApplicationsApplicationSpecSourcePluginEnv {
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GitOpsApplicationsApplicationSpecSyncPolicy {
        automateds?: outputs.platform.GitOpsApplicationsApplicationSpecSyncPolicyAutomated[];
        retries?: outputs.platform.GitOpsApplicationsApplicationSpecSyncPolicyRetry[];
        syncOptions?: string[];
    }

    export interface GitOpsApplicationsApplicationSpecSyncPolicyAutomated {
        allowEmpty?: boolean;
        prune?: boolean;
        selfHeal?: boolean;
    }

    export interface GitOpsApplicationsApplicationSpecSyncPolicyRetry {
        backoffs?: outputs.platform.GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoff[];
        limit?: string;
    }

    export interface GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoff {
        duration?: string;
        factor?: string;
        maxDuration?: string;
    }

    export interface GitOpsClusterQuery {
        /**
         * Cluster server URL or the cluster name.
         */
        ids?: outputs.platform.GitOpsClusterQueryId[];
        /**
         * Name of the GitOps cluster.
         */
        name?: string;
        /**
         * Server of the GitOps cluster.
         */
        server?: string;
    }

    export interface GitOpsClusterQueryId {
        type?: string;
        value?: string;
    }

    export interface GitOpsClusterRequest {
        /**
         * GitOps cluster details.
         */
        clusters?: outputs.platform.GitOpsClusterRequestCluster[];
        /**
         * Cluster server URL or the cluster name.
         */
        ids?: outputs.platform.GitOpsClusterRequestId[];
        /**
         * Tags associated with the clusters
         */
        tags?: string[];
        /**
         * Update mask of the GitOps cluster.
         */
        updateMasks?: outputs.platform.GitOpsClusterRequestUpdateMask[];
        /**
         * Fields which are updated.
         */
        updatedFields: string[];
        /**
         * Indicates if the GitOps cluster should be updated if existing and inserted if not.
         */
        upsert?: boolean;
    }

    export interface GitOpsClusterRequestCluster {
        annotations?: {[key: string]: string};
        clusterResources?: boolean;
        configs: outputs.platform.GitOpsClusterRequestClusterConfig[];
        infos: outputs.platform.GitOpsClusterRequestClusterInfo[];
        labels?: {[key: string]: string};
        name?: string;
        namespaces: string[];
        project: string;
        refreshRequestedAts?: outputs.platform.GitOpsClusterRequestClusterRefreshRequestedAt[];
        server: string;
        shard?: string;
    }

    export interface GitOpsClusterRequestClusterConfig {
        awsAuthConfigs?: outputs.platform.GitOpsClusterRequestClusterConfigAwsAuthConfig[];
        bearerToken?: string;
        clusterConnectionType?: string;
        execProviderConfigs?: outputs.platform.GitOpsClusterRequestClusterConfigExecProviderConfig[];
        password?: string;
        tlsClientConfigs?: outputs.platform.GitOpsClusterRequestClusterConfigTlsClientConfig[];
        username?: string;
    }

    export interface GitOpsClusterRequestClusterConfigAwsAuthConfig {
        clusterName?: string;
        roleARN?: string;
    }

    export interface GitOpsClusterRequestClusterConfigExecProviderConfig {
        apiVersion?: string;
        args: string[];
        command?: string;
        env?: {[key: string]: string};
        installHint?: string;
    }

    export interface GitOpsClusterRequestClusterConfigTlsClientConfig {
        caData?: string;
        certData?: string;
        insecure?: boolean;
        keyData?: string;
        serverName?: string;
    }

    export interface GitOpsClusterRequestClusterInfo {
        apiVersions: string[];
        applicationsCount?: string;
        cacheInfos: outputs.platform.GitOpsClusterRequestClusterInfoCacheInfo[];
        connectionStates: outputs.platform.GitOpsClusterRequestClusterInfoConnectionState[];
        serverVersion: string;
    }

    export interface GitOpsClusterRequestClusterInfoCacheInfo {
        apisCount?: string;
        lastCacheSyncTime?: string;
        resourcesCount?: string;
    }

    export interface GitOpsClusterRequestClusterInfoConnectionState {
        attemptedAts: outputs.platform.GitOpsClusterRequestClusterInfoConnectionStateAttemptedAt[];
        message: string;
        status: string;
    }

    export interface GitOpsClusterRequestClusterInfoConnectionStateAttemptedAt {
        nanos?: number;
        seconds?: string;
    }

    export interface GitOpsClusterRequestClusterRefreshRequestedAt {
        nanos?: number;
        seconds?: string;
    }

    export interface GitOpsClusterRequestId {
        type?: string;
        value?: string;
    }

    export interface GitOpsClusterRequestUpdateMask {
        paths?: string[];
    }

    export interface GitOpsGnupgRequest {
        /**
         * Public key details.
         */
        publickeys?: outputs.platform.GitOpsGnupgRequestPublickey[];
        /**
         * Indicates if the GnuPG Key should be inserted if not present or updated if present.
         */
        upsert: boolean;
    }

    export interface GitOpsGnupgRequestPublickey {
        fingerprint: string;
        keyData: string;
        keyId: string;
        owner: string;
        subType: string;
        trust: string;
    }

    export interface GitOpsRepoCertRequest {
        /**
         * certificates details.
         */
        certificates: outputs.platform.GitOpsRepoCertRequestCertificate[];
        /**
         * if the Repository Certificates should be upserted.
         */
        upsert?: boolean;
    }

    export interface GitOpsRepoCertRequestCertificate {
        items?: outputs.platform.GitOpsRepoCertRequestCertificateItem[];
        metadatas?: outputs.platform.GitOpsRepoCertRequestCertificateMetadata[];
    }

    export interface GitOpsRepoCertRequestCertificateItem {
        certData?: string;
        certInfo?: string;
        certSubType?: string;
        certType?: string;
        serverName?: string;
    }

    export interface GitOpsRepoCertRequestCertificateMetadata {
        continue?: string;
        remainingItemCount?: string;
        resourceVersion?: string;
        selfLink?: string;
    }

    export interface GitOpsRepoCredCred {
        /**
         * Specifies whether helm-oci support should be enabled for this repo.
         */
        enableOci?: boolean;
        /**
         * Specifies the GitHub API URL for GitHub app authentication.
         */
        githubAppEnterpriseBaseUrl?: string;
        /**
         * Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
         */
        githubAppId?: string;
        /**
         * Specifies the ID of the installed GitHub App for GitHub app authentication.
         */
        githubAppInstallationId?: string;
        /**
         * github*app*private_key specifies the private key PEM data for authentication via GitHub app.
         */
        githubAppPrivateKey?: string;
        /**
         * Password for authenticating at the repo server.
         */
        password?: string;
        /**
         * Contains the private key data for authenticating at the repo server using SSH (only Git repos).
         */
        sshPrivateKey?: string;
        /**
         * Specifies the TLS client cert data for authenticating at the repo server.
         */
        tlsClientCertData?: string;
        /**
         * Specifies the TLS client cert key for authenticating at the repo server.
         */
        tlsClientCertKey?: string;
        /**
         * Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
         */
        type?: string;
        /**
         * url representing this object.
         */
        url?: string;
        /**
         * Username for authenticating at the repo server.
         */
        username?: string;
    }

    export interface GitOpsRepositoryRepo {
        /**
         * Identifies the authentication method used to connect to the repository.
         */
        connectionType: string;
        /**
         * Indicates if git-lfs support must be enabled for this repo. This is valid only for Git repositories.
         */
        enableLfs?: boolean;
        /**
         * Indicates if helm-oci support must be enabled for this repo.
         */
        enableOci?: boolean;
        /**
         * Base URL of GitHub Enterprise installation. If left empty, this defaults to https://api.github.com.
         */
        githubAppEnterpriseBaseUrl?: string;
        /**
         * Id of the GitHub app used to access the repo.
         */
        githubAppId?: string;
        /**
         * Installation id of the GitHub app used to access the repo.
         */
        githubAppInstallationId?: string;
        /**
         * GitHub app private key PEM data.
         */
        githubAppPrivateKey?: string;
        /**
         * Indicates if the credentials were inherited from a credential set.
         */
        inheritedCreds?: boolean;
        /**
         * Indicates if the connection to the repository ignores any errors when verifying TLS certificates or SSH host keys.
         */
        insecure?: boolean;
        /**
         * Indicates if InsecureIgnoreHostKey should be used. Insecure is favored used only for git repos.
         */
        insecureIgnoreHostKey?: boolean;
        /**
         * Name to be used for this repo. Only used with Helm repos.
         */
        name?: string;
        /**
         * Password or PAT used for authenticating at the remote repository.
         */
        password?: string;
        /**
         * Reference between project and repository that allow you automatically to be added as item inside SourceRepos project entity.
         */
        project: string;
        /**
         * The HTTP/HTTPS proxy used to access the repo.
         */
        proxy?: string;
        /**
         * URL to the remote repository.
         */
        repo: string;
        /**
         * PEM data for authenticating at the repo server. Only used with Git repos.
         */
        sshPrivateKey?: string;
        /**
         * Certificate in PEM format for authenticating at the repo server.
         */
        tlsClientCertData?: string;
        /**
         * Private key in PEM format for authenticating at the repo server.
         */
        tlsClientCertKey?: string;
        /**
         * Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.
         */
        type_: string;
        /**
         * Username used for authenticating at the remote repository.
         */
        username?: string;
    }

    export interface GitOpsRepositoryUpdateMask {
        /**
         * The set of field mask paths.
         */
        paths?: string[];
    }

    export interface GithubConnectorApiAuthentication {
        /**
         * Configuration for using the github app for interacting with the github api.
         */
        githubApp?: outputs.platform.GithubConnectorApiAuthenticationGithubApp;
        /**
         * Personal access token for interacting with the github api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        tokenRef?: string;
    }

    export interface GithubConnectorApiAuthenticationGithubApp {
        applicationId?: string;
        applicationIdRef?: string;
        installationId?: string;
        installationIdRef?: string;
        privateKeyRef: string;
    }

    export interface GithubConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: outputs.platform.GithubConnectorCredentialsHttp;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: outputs.platform.GithubConnectorCredentialsSsh;
    }

    export interface GithubConnectorCredentialsHttp {
        tokenRef: string;
        username?: string;
        usernameRef?: string;
    }

    export interface GithubConnectorCredentialsSsh {
        sshKeyRef: string;
    }

    export interface GitlabConnectorApiAuthentication {
        /**
         * Personal access token for interacting with the gitlab api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        tokenRef: string;
    }

    export interface GitlabConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: outputs.platform.GitlabConnectorCredentialsHttp;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: outputs.platform.GitlabConnectorCredentialsSsh;
    }

    export interface GitlabConnectorCredentialsHttp {
        passwordRef?: string;
        tokenRef?: string;
        username?: string;
        usernameRef?: string;
    }

    export interface GitlabConnectorCredentialsSsh {
        sshKeyRef: string;
    }

    export interface HelmConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username?: string;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: string;
    }

    export interface InputSetGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch: string;
        /**
         * Name of the branch.
         */
        branchName?: string;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: string;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: string;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: string;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId: string;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId: string;
        /**
         * Connector reference for Parent Entity (Pipeline). To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        parentEntityConnectorRef: string;
        /**
         * Repository name for Parent Entity (Pipeline).
         */
        parentEntityRepoName: string;
        /**
         * Name of the repository.
         */
        repoName?: string;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: string;
    }

    export interface JenkinsConnectorAuth {
        /**
         * Authenticate to App Dynamics using bearer token.
         */
        jenkinsBearerToken?: outputs.platform.JenkinsConnectorAuthJenkinsBearerToken;
        /**
         * Authenticate to App Dynamics using user name and password.
         */
        jenkinsUserNamePassword?: outputs.platform.JenkinsConnectorAuthJenkinsUserNamePassword;
        /**
         * Can be one of UsernamePassword, Anonymous, Bearer Token(HTTP Header)
         */
        type: string;
    }

    export interface JenkinsConnectorAuthJenkinsBearerToken {
        tokenRef: string;
    }

    export interface JenkinsConnectorAuthJenkinsUserNamePassword {
        passwordRef: string;
        username?: string;
        usernameRef?: string;
    }

    export interface JiraConnectorAuth {
        /**
         * Authentication types for Jira connector
         */
        authType: string;
        /**
         * Authenticate using username password.
         */
        usernamePassword?: outputs.platform.JiraConnectorAuthUsernamePassword;
    }

    export interface JiraConnectorAuthUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username?: string;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: string;
    }

    export interface KubernetesConnectorClientKeyCert {
        /**
         * Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        caCertRef?: string;
        /**
         * Reference to the secret containing the client certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientCertRef: string;
        /**
         * The algorithm used to generate the client key for the connector. Valid values are RSA, EC
         */
        clientKeyAlgorithm: string;
        /**
         * Reference to the secret containing the client key passphrase for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientKeyPassphraseRef?: string;
        /**
         * Reference to the secret containing the client key for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientKeyRef: string;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: string;
    }

    export interface KubernetesConnectorInheritFromDelegate {
        /**
         * Selectors to use for the delegate.
         */
        delegateSelectors: string[];
    }

    export interface KubernetesConnectorOpenidConnect {
        /**
         * Reference to the secret containing the client ID for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientIdRef: string;
        /**
         * The URL of the OpenID Connect issuer.
         */
        issuerUrl: string;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: string;
        /**
         * Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * Scopes to request for the connector.
         */
        scopes?: string[];
        /**
         * Reference to the secret containing the client secret for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        secretRef?: string;
        /**
         * Username for the connector.
         */
        username?: string;
        /**
         * Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: string;
    }

    export interface KubernetesConnectorServiceAccount {
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: string;
        /**
         * Reference to the secret containing the service account token for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        serviceAccountTokenRef: string;
    }

    export interface KubernetesConnectorUsernamePassword {
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: string;
        /**
         * Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * Username for the connector.
         */
        username?: string;
        /**
         * Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: string;
    }

    export interface ManualFreezeCurrentOrUpcomingWindow {
        /**
         * End time of the freeze
         */
        endTime: number;
        /**
         * Start time of the freeze
         */
        startTime: number;
    }

    export interface ManualFreezeFreezeWindow {
        /**
         * Duration of the freeze
         */
        duration: string;
        /**
         * End time of the freeze
         */
        endTime: string;
        recurrences: outputs.platform.ManualFreezeFreezeWindowRecurrence[];
        /**
         * Start time of the freeze
         */
        startTime: string;
        /**
         * Timezone
         */
        timeZone: string;
    }

    export interface ManualFreezeFreezeWindowRecurrence {
        recurrenceSpecs: outputs.platform.ManualFreezeFreezeWindowRecurrenceRecurrenceSpec[];
        /**
         * Type of freeze
         */
        type: string;
    }

    export interface ManualFreezeFreezeWindowRecurrenceRecurrenceSpec {
        until: string;
        value: number;
    }

    export interface MonitoredServiceRequest {
        /**
         * Set of change sources for the monitored service.
         */
        changeSources?: outputs.platform.MonitoredServiceRequestChangeSource[];
        /**
         * Dependencies of the monitored service.
         */
        dependencies?: outputs.platform.MonitoredServiceRequestDependency[];
        /**
         * Description for the monitored service.
         */
        description?: string;
        /**
         * Enable or disable the monitored service.
         */
        enabled?: boolean;
        /**
         * Environment in which the service is deployed.
         */
        environmentRef: string;
        /**
         * Environment reference list for the monitored service.
         */
        environmentRefLists?: string[];
        /**
         * Set of health sources for the monitored service.
         */
        healthSources?: outputs.platform.MonitoredServiceRequestHealthSource[];
        /**
         * Name for the monitored service.
         */
        name: string;
        /**
         * Notification rule references for the monitored service.
         */
        notificationRuleRefs?: outputs.platform.MonitoredServiceRequestNotificationRuleRef[];
        /**
         * Service reference for the monitored service.
         */
        serviceRef: string;
        /**
         * Tags for the monitored service. comma-separated key value string pairs.
         */
        tags?: string[];
        /**
         * Template reference for the monitored service.
         */
        templateRef?: string;
        /**
         * Type of the monitored service.
         */
        type: string;
        /**
         * Template version label for the monitored service.
         */
        versionLabel?: string;
    }

    export interface MonitoredServiceRequestChangeSource {
        category: string;
        enabled?: boolean;
        /**
         * Identifier of the monitored service.
         */
        identifier: string;
        name: string;
        spec?: string;
        type: string;
    }

    export interface MonitoredServiceRequestDependency {
        dependencyMetadata?: string;
        monitoredServiceIdentifier: string;
        type: string;
    }

    export interface MonitoredServiceRequestHealthSource {
        /**
         * Identifier of the monitored service.
         */
        identifier: string;
        name: string;
        spec: string;
        type: string;
    }

    export interface MonitoredServiceRequestNotificationRuleRef {
        enabled: boolean;
        notificationRuleRef: string;
    }

    export interface NexusConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username?: string;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: string;
    }

    export interface OciHelmConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username?: string;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: string;
    }

    export interface PipelineFiltersFilterProperties {
        /**
         * Corresponding Entity of the filters. Currently supported types are {Connector, DelegateProfile, Delegate, PipelineSetup, PipelineExecution, Deployment, Audit, Template, EnvironmentGroup, FileStore, CCMRecommendation, Anomaly, Environment}.
         */
        filterType: string;
        /**
         * Tags to associate with the resource. Tags should be in the form `name:value`.
         */
        tags?: string[];
    }

    export interface PipelineGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch: string;
        /**
         * Name of the branch.
         */
        branchName?: string;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: string;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: string;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: string;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId: string;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId: string;
        /**
         * Name of the repository.
         */
        repoName?: string;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: string;
    }

    export interface PolicySetPolicy {
        /**
         * Account Identifier of the account
         */
        identifier: string;
        /**
         * Policy failure response - 'warning' for continuation, 'error' for exit
         */
        severity: string;
    }

    export interface PrometheusConnectorHeader {
        /**
         * Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        encryptedValueRef?: string;
        /**
         * Key.
         */
        key: string;
        /**
         * Value.
         */
        value?: string;
        /**
         * Encrypted value.
         */
        valueEncrypted?: boolean;
    }

    export interface ResourceGroupIncludedScope {
        /**
         * Account Identifier of the account
         */
        accountId?: string;
        /**
         * Can be one of these 2 EXCLUDING*CHILD*SCOPES or INCLUDING*CHILD*SCOPES
         */
        filter: string;
        /**
         * Organization Identifier
         */
        orgId?: string;
        /**
         * Project Identifier
         */
        projectId?: string;
    }

    export interface ResourceGroupResourceFilter {
        /**
         * Include all resource or not
         */
        includeAllResources?: boolean;
        /**
         * Resources for a resource group
         */
        resources?: outputs.platform.ResourceGroupResourceFilterResource[];
    }

    export interface ResourceGroupResourceFilterResource {
        attributeFilters?: outputs.platform.ResourceGroupResourceFilterResourceAttributeFilter[];
        identifiers?: string[];
        resourceType: string;
    }

    export interface ResourceGroupResourceFilterResourceAttributeFilter {
        attributeName?: string;
        attributeValues?: string[];
    }

    export interface RoleAssignmentsPrincipal {
        /**
         * Identifier.
         */
        identifier?: string;
        /**
         * Scope level.
         */
        scopeLevel: string;
        /**
         * Type.
         */
        type: string;
    }

    export interface SecretSshkeyKerberos {
        /**
         * Username to use for authentication.
         */
        principal: string;
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        realm: string;
        /**
         * Method to generate tgt
         */
        tgtGenerationMethod?: string;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtKeyTabFilePathSpec?: outputs.platform.SecretSshkeyKerberosTgtKeyTabFilePathSpec;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtPasswordSpec?: outputs.platform.SecretSshkeyKerberosTgtPasswordSpec;
    }

    export interface SecretSshkeyKerberosTgtKeyTabFilePathSpec {
        keyPath?: string;
    }

    export interface SecretSshkeyKerberosTgtPasswordSpec {
        password?: string;
    }

    export interface SecretSshkeySsh {
        /**
         * This specifies SSH credential type as Password, KeyPath or KeyReference
         */
        credentialType: string;
        /**
         * SSH credential of type keyReference
         */
        sshPasswordCredential?: outputs.platform.SecretSshkeySshSshPasswordCredential;
        /**
         * SSH credential of type keyPath
         */
        sshkeyPathCredential?: outputs.platform.SecretSshkeySshSshkeyPathCredential;
        /**
         * SSH credential of type keyReference
         */
        sshkeyReferenceCredential?: outputs.platform.SecretSshkeySshSshkeyReferenceCredential;
    }

    export interface SecretSshkeySshSshPasswordCredential {
        password: string;
        userName: string;
    }

    export interface SecretSshkeySshSshkeyPathCredential {
        encryptedPassphrase?: string;
        keyPath: string;
        userName: string;
    }

    export interface SecretSshkeySshSshkeyReferenceCredential {
        encryptedPassphrase?: string;
        key: string;
        userName: string;
    }

    export interface ServiceNowConnectorAuth {
        /**
         * Authenticate using adfs client credentials with certificate.
         */
        adfs?: outputs.platform.ServiceNowConnectorAuthAdfs;
        /**
         * Authentication types for Jira connector
         */
        authType: string;
        /**
         * Authenticate using username password.
         */
        usernamePassword?: outputs.platform.ServiceNowConnectorAuthUsernamePassword;
    }

    export interface ServiceNowConnectorAuthAdfs {
        adfsUrl: string;
        certificateRef: string;
        clientIdRef: string;
        privateKeyRef: string;
        resourceIdRef: string;
    }

    export interface ServiceNowConnectorAuthUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * Username to use for authentication.
         */
        username?: string;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: string;
    }

    export interface SloRequest {
        /**
         * Description for the SLO.
         */
        description?: string;
        /**
         * Name for the SLO.
         */
        name: string;
        /**
         * Notification rule references for the SLO.
         */
        notificationRuleRefs?: outputs.platform.SloRequestNotificationRuleRef[];
        /**
         * SLO Target specification.
         */
        sloTarget: outputs.platform.SloRequestSloTarget;
        /**
         * Specification of the SLO.
         */
        spec: string;
        /**
         * Tags for the SLO. comma-separated key value string pairs.
         */
        tags?: string[];
        /**
         * Type of the SLO.
         */
        type: string;
        /**
         * User journey reference list for the SLO.
         */
        userJourneyRefs: string[];
    }

    export interface SloRequestNotificationRuleRef {
        enabled: boolean;
        notificationRuleRef: string;
    }

    export interface SloRequestSloTarget {
        sloTargetPercentage: number;
        spec: string;
        type: string;
    }

    export interface SpotConnectorPermanentToken {
        /**
         * Reference to the Harness secret containing the permanent api token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        apiTokenRef: string;
        /**
         * Connect only using delegates with these tags.
         */
        delegateSelectors?: string[];
        /**
         * Execute on delegate or not.
         */
        executeOnDelegate?: boolean;
        /**
         * Spot account id.
         */
        spotAccountId?: string;
        /**
         * Reference to the Harness secret containing the spot account id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        spotAccountIdRef?: string;
    }

    export interface TasConnectorCredentials {
        /**
         * Authenticate to Tas using manual details.
         */
        tasManualDetails: outputs.platform.TasConnectorCredentialsTasManualDetails;
        /**
         * Type can be ManualConfig.
         */
        type: string;
    }

    export interface TasConnectorCredentialsTasManualDetails {
        endpointUrl: string;
        passwordRef: string;
        username?: string;
        usernameRef?: string;
    }

    export interface TemplateFiltersFilterProperties {
        /**
         * Corresponding Entity of the filters. Currently supported types are {TemplateSetup, TemplateExecution, Template}.
         */
        filterType: string;
        /**
         * Tags to associate with the resource. Tags should be in the form `name:value`.
         */
        tags?: string[];
    }

    export interface TemplateGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch: string;
        /**
         * Name of the branch.
         */
        branchName: string;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage: string;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef: string;
        /**
         * File path of the Entity in the repository.
         */
        filePath: string;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId: string;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId: string;
        /**
         * Name of the repository.
         */
        repoName: string;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType: string;
    }

    export interface TerraformCloudConnectorCredentials {
        /**
         * API token credentials to use for authentication.
         */
        apiToken: outputs.platform.TerraformCloudConnectorCredentialsApiToken;
    }

    export interface TerraformCloudConnectorCredentialsApiToken {
        apiTokenRef: string;
    }

    export interface UserRoleBinding {
        /**
         * Managed Role of the user.
         */
        managedRole?: boolean;
        /**
         * Resource Group Identifier of the user.
         */
        resourceGroupIdentifier?: string;
        /**
         * Resource Group Name of the user.
         */
        resourceGroupName?: string;
        /**
         * Role Identifier of the user.
         */
        roleIdentifier?: string;
        /**
         * Role Name Identifier of the user.
         */
        roleName?: string;
    }

    export interface UsergroupNotificationConfig {
        /**
         * Group email.
         */
        groupEmail?: string;
        /**
         * Url of Microsoft teams webhook.
         */
        microsoftTeamsWebhookUrl?: string;
        /**
         * Pager duty key.
         */
        pagerDutyKey?: string;
        /**
         * Send email to all the group members.
         */
        sendEmailToAllUsers: boolean;
        /**
         * Url of slack webhook.
         */
        slackWebhookUrl?: string;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
         */
        type?: string;
    }

    export interface VariablesSpec {
        /**
         * FixedValue of the variable
         */
        fixedValue: string;
        /**
         * Type of Value of the Variable. For now only FIXED is supported
         */
        valueType: string;
    }

}

export namespace service {
    export interface AmiVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface CodedeployVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface EcsVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface HelmVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface KubernetesVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface LambdaVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface SshVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface TanzuVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

    export interface WinrmVariable {
        /**
         * Name of the variable
         */
        name: string;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: string;
        /**
         * Value of the variable
         */
        value: string;
    }

}
