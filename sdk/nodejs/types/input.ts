// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface EncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface EnvironmentVariableOverride {
    /**
     * The name of the variable
     */
    name: pulumi.Input<string>;
    /**
     * The name of the service
     */
    serviceName?: pulumi.Input<string>;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type: pulumi.Input<string>;
    /**
     * The value of the service variable
     */
    value: pulumi.Input<string>;
}

export interface GetEncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetEncryptedTextUsageScopeArgs {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface GetEnvironmentVariableOverride {
    /**
     * The name of the variable
     */
    name?: string;
    /**
     * The name of the service
     */
    serviceName?: string;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type?: string;
    /**
     * The value of the service variable
     */
    value?: string;
}

export interface GetEnvironmentVariableOverrideArgs {
    /**
     * The name of the variable
     */
    name?: pulumi.Input<string>;
    /**
     * The name of the service
     */
    serviceName?: pulumi.Input<string>;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type?: pulumi.Input<string>;
    /**
     * The value of the service variable
     */
    value?: pulumi.Input<string>;
}

export interface GetSecretManagerUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetSecretManagerUsageScopeArgs {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface GetSshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetSshCredentialUsageScopeArgs {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface GitConnectorCommitDetails {
    /**
     * The email id of the author
     */
    authorEmailId?: pulumi.Input<string>;
    /**
     * The name of the author
     */
    authorName?: pulumi.Input<string>;
    /**
     * Commit message
     */
    message?: pulumi.Input<string>;
}

export interface GitConnectorUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsAmi {
    /**
     * The ami deployment type to use. Valid options are AWS_ASG, SPOTINST
     */
    amiDeploymentType: pulumi.Input<string>;
    /**
     * Flag to indicate whether the autoscaling group identifies the workload.
     */
    asgIdentifiesWorkload?: pulumi.Input<boolean>;
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: pulumi.Input<string>;
    /**
     * The classic load balancers to use.
     */
    classicLoadbalancers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The name of the SpotInst cloud provider to connect with.
     */
    spotinstCloudProviderName?: pulumi.Input<string>;
    /**
     * The SpotInst configuration to use.
     */
    spotinstConfigJson?: pulumi.Input<string>;
    /**
     * The staging classic load balancers to use.
     */
    stageClassicLoadbalancers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The staging classic load balancers to use.
     */
    stageTargetGroupArns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ARN's of the target groups.
     */
    targetGroupArns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Flag to enable traffic shifting.
     */
    useTrafficShift?: pulumi.Input<boolean>;
}

export interface InfrastructureDefinitionAwsEcs {
    /**
     * Flag to assign a public IP address.
     */
    assignPublicIp?: pulumi.Input<boolean>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the ECS cluster to use.
     */
    clusterName: pulumi.Input<string>;
    /**
     * The ARN of the role to use for execution.
     */
    executionRole?: pulumi.Input<string>;
    /**
     * The type of launch configuration to use. Valid options are FARGATE
     */
    launchType: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsLambda {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The IAM role to use.
     */
    iamRole?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsSsh {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: pulumi.Input<string>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The desired capacity of the auto scaling group.
     */
    desiredCapacity?: pulumi.Input<number>;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: pulumi.Input<string>;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: pulumi.Input<string>;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: pulumi.Input<string>;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The tags to use when selecting the instances.
     */
    tags?: pulumi.Input<pulumi.Input<inputs.InfrastructureDefinitionAwsSshTag>[]>;
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InfrastructureDefinitionAwsSshTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsWinrm {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName: pulumi.Input<string>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The desired capacity of the autoscaling group.
     */
    desiredCapacity?: pulumi.Input<number>;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName: pulumi.Input<string>;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: pulumi.Input<string>;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: pulumi.Input<string>;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAzureVmss {
    /**
     * The type of authentication to use. Valid options are SSH*PUBLIC*KEY.
     */
    authType: pulumi.Input<string>;
    /**
     * Base name.
     */
    baseName: pulumi.Input<string>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The type of deployment. Valid options are NATIVE_VMSS
     */
    deploymentType: pulumi.Input<string>;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: pulumi.Input<string>;
    /**
     * The name of the resource group.
     */
    resourceGroupName: pulumi.Input<string>;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: pulumi.Input<string>;
    /**
     * The username to connect with.
     */
    username: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAzureWebapp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the resource group.
     */
    resourceGroup: pulumi.Input<string>;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: pulumi.Input<string>;
}

export interface InfrastructureDefinitionCustom {
    /**
     * The template version
     */
    deploymentTypeTemplateVersion: pulumi.Input<string>;
    /**
     * Variables to be used in the service
     */
    variables?: pulumi.Input<pulumi.Input<inputs.InfrastructureDefinitionCustomVariable>[]>;
}

export interface InfrastructureDefinitionCustomVariable {
    /**
     * The name of the infrastructure definition
     */
    name: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface InfrastructureDefinitionDatacenterSsh {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the SSH connection attributes to use.
     */
    hostConnectionAttributesName: pulumi.Input<string>;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InfrastructureDefinitionDatacenterWinrm {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the WinRM connection attributes to use.
     */
    winrmConnectionAttributesName: pulumi.Input<string>;
}

export interface InfrastructureDefinitionKubernetes {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: pulumi.Input<string>;
    /**
     * The naming convention of the release. When using Helm Native the default is ${infra.kubernetes.infraId}. For standard Kubernetes manifests the default is release-${infra.kubernetes.infraId}
     */
    releaseName: pulumi.Input<string>;
}

export interface InfrastructureDefinitionKubernetesGcp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the cluster being deployed to.
     */
    clusterName: pulumi.Input<string>;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: pulumi.Input<string>;
    /**
     * The naming convention of the release.
     */
    releaseName: pulumi.Input<string>;
}

export interface InfrastructureDefinitionTanzu {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The PCF organization to use.
     */
    organization: pulumi.Input<string>;
    /**
     * The PCF space to deploy to.
     */
    space: pulumi.Input<string>;
}

export interface PlatformCcmFiltersFilterProperties {
    /**
     * Type of CCM filters.
     */
    filterType: pulumi.Input<string>;
    /**
     * Tags to associate with the resource. Tags should be in the form `name:value`.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SshCredentialKerberosAuthentication {
    /**
     * Port to use for Kerberos authentication
     */
    port: pulumi.Input<number>;
    /**
     * Name of the principal for authentication
     */
    principal: pulumi.Input<string>;
    /**
     * Realm associated with the Kerberos authentication
     */
    realm: pulumi.Input<string>;
    /**
     * TGT generation method
     */
    tgtGenerationMethod?: pulumi.Input<inputs.SshCredentialKerberosAuthenticationTgtGenerationMethod>;
}

export interface SshCredentialKerberosAuthenticationTgtGenerationMethod {
    kerberosPasswordId?: pulumi.Input<string>;
    keyTabFilePath?: pulumi.Input<string>;
}

export interface SshCredentialSshAuthentication {
    /**
     * Inline SSH authentication configuration. Only ond of `passphraseSecretId` or `sshKeyFileId` should be used
     */
    inlineSsh?: pulumi.Input<inputs.SshCredentialSshAuthenticationInlineSsh>;
    /**
     * The port to connect to
     */
    port: pulumi.Input<number>;
    /**
     * Server password authentication configuration
     */
    serverPassword?: pulumi.Input<inputs.SshCredentialSshAuthenticationServerPassword>;
    /**
     * Use ssh key file for authentication
     */
    sshKeyFile?: pulumi.Input<inputs.SshCredentialSshAuthenticationSshKeyFile>;
    /**
     * The username to use when connecting to ssh
     */
    username: pulumi.Input<string>;
}

export interface SshCredentialSshAuthenticationInlineSsh {
    passphraseSecretId?: pulumi.Input<string>;
    sshKeyFileId: pulumi.Input<string>;
}

export interface SshCredentialSshAuthenticationServerPassword {
    passwordSecretId: pulumi.Input<string>;
}

export interface SshCredentialSshAuthenticationSshKeyFile {
    passphraseSecretId?: pulumi.Input<string>;
    path: pulumi.Input<string>;
}

export interface SshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface UserGroupLdapSettings {
    /**
     * The group DN of the LDAP user group.
     */
    groupDn?: pulumi.Input<string>;
    /**
     * The group name of the LDAP user group.
     */
    groupName?: pulumi.Input<string>;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: pulumi.Input<string>;
}

export interface UserGroupNotificationSettings {
    /**
     * The email addresses of the user group.
     */
    groupEmailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The Microsoft Teams webhook URL of the user group.
     */
    microsoftTeamsWebhookUrl?: pulumi.Input<string>;
    /**
     * Indicates whether an email is sent when a new user is added to the group.
     */
    sendMailToNewMembers?: pulumi.Input<boolean>;
    /**
     * Enable this setting to have notifications sent to the members of this group.
     */
    sendNotificationsToMembers?: pulumi.Input<boolean>;
    /**
     * The Slack channel to send notifications to.
     */
    slackChannel?: pulumi.Input<string>;
    /**
     * The Slack webhook URL to send notifications to.
     */
    slackWebhookUrl?: pulumi.Input<string>;
}

export interface UserGroupPermissions {
    /**
     * The account permissions of the user group. Valid options are ADMINISTER*OTHER*ACCOUNT*FUNCTIONS, CREATE*AND*DELETE*APPLICATION, CREATE*CUSTOM*DASHBOARDS, MANAGE*ALERT*NOTIFICATION*RULES, MANAGE*API*KEYS, MANAGE*APPLICATION*STACKS, MANAGE*AUTHENTICATION*SETTINGS, MANAGE*CLOUD*PROVIDERS, MANAGE*CONFIG*AS*CODE, MANAGE*CONNECTORS, MANAGE*CUSTOM*DASHBOARDS, MANAGE*DELEGATE*PROFILES, MANAGE*DELEGATES, MANAGE*DEPLOYMENT*FREEZES, MANAGE*IP*WHITELIST, MANAGE*PIPELINE*GOVERNANCE*STANDARDS, MANAGE*RESTRICTED*ACCESS, MANAGE*SECRET*MANAGERS, MANAGE*SECRETS, MANAGE*SSH*AND*WINRM, MANAGE*TAGS, MANAGE*TEMPLATE*LIBRARY, MANAGE*USER*AND*USER*GROUPS*AND*API*KEYS, MANAGE*USERS*AND*GROUPS, READ*USERS*AND*GROUPS, VIEW*AUDITS, VIEW*USER*AND*USER*GROUPS*AND*API_KEYS
     */
    accountPermissions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Application specific permissions
     */
    appPermissions?: pulumi.Input<inputs.UserGroupPermissionsAppPermissions>;
}

export interface UserGroupPermissionsAppPermissions {
    /**
     * The permission to perform actions against all resources.
     */
    alls?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsAll>[]>;
    /**
     * Permission configuration to perform actions against deployments.
     */
    deployments?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsDeployment>[]>;
    /**
     * Permission configuration to perform actions against workflows.
     */
    environments?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsEnvironment>[]>;
    /**
     * Permission configuration to perform actions against pipelines.
     */
    pipelines?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsPipeline>[]>;
    /**
     * Permission configuration to perform actions against provisioners.
     */
    provisioners?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsProvisioner>[]>;
    /**
     * Permission configuration to perform actions against services.
     */
    services?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsService>[]>;
    /**
     * Permission configuration to perform actions against templates.
     */
    templates?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsTemplate>[]>;
    /**
     * Permission configuration to perform actions against workflows.
     */
    workflows?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsWorkflow>[]>;
}

export interface UserGroupPermissionsAppPermissionsAll {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsDeployment {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    envIds?: pulumi.Input<pulumi.Input<string>[]>;
    filters?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsEnvironment {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    envIds?: pulumi.Input<pulumi.Input<string>[]>;
    filters?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsPipeline {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    envIds?: pulumi.Input<pulumi.Input<string>[]>;
    filters?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsProvisioner {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    provisionerIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsService {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    serviceIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsTemplate {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    templateIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsWorkflow {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    filters?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupSamlSettings {
    /**
     * The group name of the SAML user group.
     */
    groupName?: pulumi.Input<string>;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: pulumi.Input<string>;
}
export namespace cloudprovider {
    export interface AwsAssumeCrossAccountRole {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: pulumi.Input<string>;
        /**
         * This is an IAM role in the target deployment AWS account.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }

    export interface DatacenterUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }

    export interface GcpUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }

    export interface KubernetesAuthentication {
        /**
         * Delegate selectors to inherit the GCP credentials from.
         */
        delegateSelectors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Service account configuration for connecting to the Kubernetes cluster
         */
        oidc?: pulumi.Input<inputs.cloudprovider.KubernetesAuthenticationOidc>;
        /**
         * Username and password for authentication to the cluster
         */
        serviceAccount?: pulumi.Input<inputs.cloudprovider.KubernetesAuthenticationServiceAccount>;
        /**
         * Username and password for authentication to the cluster
         */
        usernamePassword?: pulumi.Input<inputs.cloudprovider.KubernetesAuthenticationUsernamePassword>;
    }

    export interface KubernetesAuthenticationOidc {
        clientIdSecretName: pulumi.Input<string>;
        clientSecretSecretName?: pulumi.Input<string>;
        identityProviderUrl: pulumi.Input<string>;
        masterUrl: pulumi.Input<string>;
        passwordSecretName: pulumi.Input<string>;
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        username: pulumi.Input<string>;
    }

    export interface KubernetesAuthenticationServiceAccount {
        caCertificateSecretName?: pulumi.Input<string>;
        masterUrl: pulumi.Input<string>;
        serviceAccountTokenSecretName: pulumi.Input<string>;
    }

    export interface KubernetesAuthenticationUsernamePassword {
        masterUrl: pulumi.Input<string>;
        passwordSecretName: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameSecretName?: pulumi.Input<string>;
    }

    export interface KubernetesUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }
}

export namespace platform {
    export interface AppDynamicsConnectorApiToken {
        /**
         * The client id used for connecting to App Dynamics.
         */
        clientId: pulumi.Input<string>;
        /**
         * Reference to the Harness secret containing the App Dynamics client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientSecretRef: pulumi.Input<string>;
    }

    export interface AppDynamicsConnectorUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username: pulumi.Input<string>;
    }

    export interface ArtifactoryConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface AwsCCConnectorCrossAccountAccess {
        /**
         * The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
         */
        externalId: pulumi.Input<string>;
        /**
         * The ARN of the role to use for cross-account access.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsConnectorCrossAccountAccess {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsConnectorEqualJitterBackoffStrategy {
        /**
         * Base delay.
         */
        baseDelay?: pulumi.Input<number>;
        /**
         * Max BackOff Time.
         */
        maxBackoffTime?: pulumi.Input<number>;
        /**
         * Retry Count.
         */
        retryCount?: pulumi.Input<number>;
    }

    export interface AwsConnectorFixedDelayBackoffStrategy {
        /**
         * Fixed Backoff.
         */
        fixedBackoff?: pulumi.Input<number>;
        /**
         * Retry Count.
         */
        retryCount?: pulumi.Input<number>;
    }

    export interface AwsConnectorFullJitterBackoffStrategy {
        /**
         * Base delay.
         */
        baseDelay?: pulumi.Input<number>;
        /**
         * Max BackOff Time.
         */
        maxBackoffTime?: pulumi.Input<number>;
        /**
         * Retry Count.
         */
        retryCount?: pulumi.Input<number>;
    }

    export interface AwsConnectorInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AwsConnectorIrsa {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AwsConnectorManual {
        /**
         * AWS access key.
         */
        accessKey?: pulumi.Input<string>;
        /**
         * Reference to the Harness secret containing the aws access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        accessKeyRef?: pulumi.Input<string>;
        /**
         * Connect only use delegates with these tags.
         */
        delegateSelectors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Reference to the Harness secret containing the aws secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        secretKeyRef: pulumi.Input<string>;
    }

    export interface AwsKmsConnectorCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: pulumi.Input<inputs.platform.AwsKmsConnectorCredentialsAssumeRole>;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: pulumi.Input<boolean>;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: pulumi.Input<inputs.platform.AwsKmsConnectorCredentialsManual>;
    }

    export interface AwsKmsConnectorCredentialsAssumeRole {
        duration: pulumi.Input<number>;
        externalId?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface AwsKmsConnectorCredentialsManual {
        accessKeyRef: pulumi.Input<string>;
        secretKeyRef: pulumi.Input<string>;
    }

    export interface AwsSecretManagerConnectorCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: pulumi.Input<inputs.platform.AwsSecretManagerConnectorCredentialsAssumeRole>;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: pulumi.Input<boolean>;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: pulumi.Input<inputs.platform.AwsSecretManagerConnectorCredentialsManual>;
    }

    export interface AwsSecretManagerConnectorCredentialsAssumeRole {
        duration: pulumi.Input<number>;
        externalId?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface AwsSecretManagerConnectorCredentialsManual {
        accessKeyRef: pulumi.Input<string>;
        secretKeyRef: pulumi.Input<string>;
    }

    export interface AzureCloudCostConnectorBillingExportSpec {
        /**
         * Name of the container.
         */
        containerName: pulumi.Input<string>;
        /**
         * Name of the directory.
         */
        directoryName: pulumi.Input<string>;
        /**
         * Name of the report.
         */
        reportName: pulumi.Input<string>;
        /**
         * Name of the storage account.
         */
        storageAccountName: pulumi.Input<string>;
        /**
         * Subsription Id.
         */
        subscriptionId: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentials {
        /**
         * Authenticate to Azure Cloud Provider using details inheriting from delegate.
         */
        azureInheritFromDelegateDetails?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetails>;
        /**
         * Authenticate to Azure Cloud Provider using manual details.
         */
        azureManualDetails?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureManualDetails>;
        /**
         * Type can either be InheritFromDelegate or ManualConfig.
         */
        type: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetails {
        auth?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuth>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuth {
        azureMsiAuthUa?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa>;
        type: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa {
        clientId?: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureManualDetails {
        applicationId?: pulumi.Input<string>;
        auth?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuth>;
        tenantId?: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureManualDetailsAuth {
        azureClientKeyCert?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCert>;
        azureClientSecretKey?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKey>;
        type?: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCert {
        certificateRef?: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKey {
        secretRef?: pulumi.Input<string>;
    }

    export interface BitbucketConnectorApiAuthentication {
        /**
         * Personal access token for interacting with the BitBucket api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        tokenRef: pulumi.Input<string>;
        /**
         * The username used for connecting to the api.
         */
        username?: pulumi.Input<string>;
        /**
         * The name of the Harness secret containing the username. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface BitbucketConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.platform.BitbucketConnectorCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.platform.BitbucketConnectorCredentialsSsh>;
    }

    export interface BitbucketConnectorCredentialsHttp {
        passwordRef?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface BitbucketConnectorCredentialsSsh {
        sshKeyRef: pulumi.Input<string>;
    }

    export interface DockerConnectorCredentials {
        /**
         * The reference to the Harness secret containing the password to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * The username to use for the docker registry.
         */
        username?: pulumi.Input<string>;
        /**
         * The reference to the Harness secret containing the username to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface ElasticsearchConnectorApiToken {
        /**
         * The client id used for connecting to ElasticSearch.
         */
        clientId: pulumi.Input<string>;
        /**
         * Reference to the Harness secret containing the ElasticSearch client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientSecretRef: pulumi.Input<string>;
    }

    export interface ElasticsearchConnectorNoAuthentication {
    }

    export interface ElasticsearchConnectorUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username: pulumi.Input<string>;
    }

    export interface EnvironmentClustersMappingCluster {
        /**
         * account Identifier of the account
         */
        identifier?: pulumi.Input<string>;
        /**
         * name of the cluster
         */
        name?: pulumi.Input<string>;
        /**
         * scope at which the cluster exists in harness gitops, project vs org vs account
         */
        scope?: pulumi.Input<string>;
    }

    export interface FeatureFlagGitDetails {
        /**
         * The commit message to use as part of a gitsync operation
         */
        commitMsg: pulumi.Input<string>;
    }

    export interface FeatureFlagVariation {
        /**
         * The description of the variation
         */
        description: pulumi.Input<string>;
        /**
         * The identifier of the variation
         */
        identifier: pulumi.Input<string>;
        /**
         * The user friendly name of the variation
         */
        name: pulumi.Input<string>;
        /**
         * The value of the variation
         */
        value: pulumi.Input<string>;
    }

    export interface FiltersFilterProperties {
        /**
         * Corresponding Entity of the filter. Currently supported types are {Connector, DelegateProfile, Delegate, EnvironmentGroup, FileStore, Environment}.
         */
        filterType: pulumi.Input<string>;
        /**
         * Tags to associate with the resource. Tags should be in the form `name:value`.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GcpCloudCostConnectorBillingExportSpec {
        /**
         * Data Set Id.
         */
        dataSetId: pulumi.Input<string>;
        /**
         * Table Id.
         */
        tableId: pulumi.Input<string>;
    }

    export interface GcpConnectorInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GcpConnectorManual {
        /**
         * The delegates to connect with.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        secretKeyRef: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplication {
        /**
         * Metadata corresponding to the resources. This includes all the objects a user must create.
         */
        metadatas?: inputs.platform.GetGitopsApplicationsApplicationMetadata[];
        /**
         * Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
         */
        specs?: inputs.platform.GetGitopsApplicationsApplicationSpec[];
    }

    export interface GetGitopsApplicationsApplicationArgs {
        /**
         * Metadata corresponding to the resources. This includes all the objects a user must create.
         */
        metadatas?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationMetadataArgs>[]>;
        /**
         * Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
         */
        specs?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecArgs>[]>;
    }

    export interface GetGitopsApplicationsApplicationMetadata {
        annotations?: {[key: string]: string};
        clusterName?: string;
        finalizers?: string[];
        generateName?: string;
        generation?: string;
        labels?: {[key: string]: string};
        /**
         * Name of the GitOps application.
         */
        name?: string;
        namespace?: string;
        ownerReferences?: inputs.platform.GetGitopsApplicationsApplicationMetadataOwnerReference[];
        uid?: string;
    }

    export interface GetGitopsApplicationsApplicationMetadataArgs {
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        clusterName?: pulumi.Input<string>;
        finalizers?: pulumi.Input<pulumi.Input<string>[]>;
        generateName?: pulumi.Input<string>;
        generation?: pulumi.Input<string>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        namespace?: pulumi.Input<string>;
        ownerReferences?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationMetadataOwnerReferenceArgs>[]>;
        uid?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationMetadataOwnerReference {
        apiVersion?: string;
        blockOwnerDeletion?: boolean;
        controller?: boolean;
        /**
         * Kind of the GitOps application.
         */
        kind?: string;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        uid?: string;
    }

    export interface GetGitopsApplicationsApplicationMetadataOwnerReferenceArgs {
        apiVersion?: pulumi.Input<string>;
        blockOwnerDeletion?: pulumi.Input<boolean>;
        controller?: pulumi.Input<boolean>;
        /**
         * Kind of the GitOps application.
         */
        kind?: pulumi.Input<string>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        uid?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationSpec {
        destinations?: inputs.platform.GetGitopsApplicationsApplicationSpecDestination[];
        sources?: inputs.platform.GetGitopsApplicationsApplicationSpecSource[];
        syncPolicies?: inputs.platform.GetGitopsApplicationsApplicationSpecSyncPolicy[];
    }

    export interface GetGitopsApplicationsApplicationSpecArgs {
        destinations?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecDestinationArgs>[]>;
        sources?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSourceArgs>[]>;
        syncPolicies?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSyncPolicyArgs>[]>;
    }

    export interface GetGitopsApplicationsApplicationSpecDestination {
        /**
         * Name of the GitOps application.
         */
        name?: string;
        namespace?: string;
        server?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecDestinationArgs {
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        namespace?: pulumi.Input<string>;
        server?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationSpecSource {
        chart?: string;
        directories?: inputs.platform.GetGitopsApplicationsApplicationSpecSourceDirectory[];
        helms?: inputs.platform.GetGitopsApplicationsApplicationSpecSourceHelm[];
        ksonnets?: inputs.platform.GetGitopsApplicationsApplicationSpecSourceKsonnet[];
        kustomizes?: inputs.platform.GetGitopsApplicationsApplicationSpecSourceKustomize[];
        path?: string;
        plugins?: inputs.platform.GetGitopsApplicationsApplicationSpecSourcePlugin[];
        repoUrl?: string;
        targetRevision?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceArgs {
        chart?: pulumi.Input<string>;
        directories?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSourceDirectoryArgs>[]>;
        helms?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSourceHelmArgs>[]>;
        ksonnets?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSourceKsonnetArgs>[]>;
        kustomizes?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSourceKustomizeArgs>[]>;
        path?: pulumi.Input<string>;
        plugins?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSourcePluginArgs>[]>;
        repoUrl?: pulumi.Input<string>;
        targetRevision?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceDirectory {
        exclude?: string;
        include?: string;
        jsonnets?: inputs.platform.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnet[];
        recurse?: boolean;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceDirectoryArgs {
        exclude?: pulumi.Input<string>;
        include?: pulumi.Input<string>;
        jsonnets?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetArgs>[]>;
        recurse?: pulumi.Input<boolean>;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnet {
        extVars?: inputs.platform.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar[];
        libs?: string[];
        tlas?: inputs.platform.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTla[];
    }

    export interface GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetArgs {
        extVars?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgs>[]>;
        libs?: pulumi.Input<pulumi.Input<string>[]>;
        tlas?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgs>[]>;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar {
        code?: boolean;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgs {
        code?: pulumi.Input<boolean>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTla {
        code?: boolean;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgs {
        code?: pulumi.Input<boolean>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceHelm {
        fileParameters?: inputs.platform.GetGitopsApplicationsApplicationSpecSourceHelmFileParameter[];
        parameters?: inputs.platform.GetGitopsApplicationsApplicationSpecSourceHelmParameter[];
        passCredentials?: boolean;
        releaseName?: string;
        valueFiles?: string[];
        values?: string;
        version?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceHelmArgs {
        fileParameters?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSourceHelmFileParameterArgs>[]>;
        parameters?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSourceHelmParameterArgs>[]>;
        passCredentials?: pulumi.Input<boolean>;
        releaseName?: pulumi.Input<string>;
        valueFiles?: pulumi.Input<pulumi.Input<string>[]>;
        values?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceHelmFileParameter {
        /**
         * Name of the GitOps application.
         */
        name?: string;
        path?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceHelmFileParameterArgs {
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceHelmParameter {
        forceString?: boolean;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceHelmParameterArgs {
        forceString?: pulumi.Input<boolean>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceKsonnet {
        environment?: string;
        parameters?: inputs.platform.GetGitopsApplicationsApplicationSpecSourceKsonnetParameter[];
    }

    export interface GetGitopsApplicationsApplicationSpecSourceKsonnetArgs {
        environment?: pulumi.Input<string>;
        parameters?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSourceKsonnetParameterArgs>[]>;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceKsonnetParameter {
        component?: string;
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceKsonnetParameterArgs {
        component?: pulumi.Input<string>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceKustomize {
        commonAnnotations?: {[key: string]: string};
        commonLabels?: {[key: string]: string};
        forceCommonAnnotations?: boolean;
        forceCommonLabels?: boolean;
        images?: string[];
        namePrefix?: string;
        nameSuffix?: string;
        version?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourceKustomizeArgs {
        commonAnnotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        commonLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        forceCommonAnnotations?: pulumi.Input<boolean>;
        forceCommonLabels?: pulumi.Input<boolean>;
        images?: pulumi.Input<pulumi.Input<string>[]>;
        namePrefix?: pulumi.Input<string>;
        nameSuffix?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationSpecSourcePlugin {
        envs?: inputs.platform.GetGitopsApplicationsApplicationSpecSourcePluginEnv[];
        /**
         * Name of the GitOps application.
         */
        name?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourcePluginArgs {
        envs?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSourcePluginEnvArgs>[]>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationSpecSourcePluginEnv {
        /**
         * Name of the GitOps application.
         */
        name?: string;
        value?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSourcePluginEnvArgs {
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationSpecSyncPolicy {
        automateds?: inputs.platform.GetGitopsApplicationsApplicationSpecSyncPolicyAutomated[];
        retries?: inputs.platform.GetGitopsApplicationsApplicationSpecSyncPolicyRetry[];
        syncOptions?: string[];
    }

    export interface GetGitopsApplicationsApplicationSpecSyncPolicyArgs {
        automateds?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSyncPolicyAutomatedArgs>[]>;
        retries?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSyncPolicyRetryArgs>[]>;
        syncOptions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GetGitopsApplicationsApplicationSpecSyncPolicyAutomated {
        allowEmpty?: boolean;
        prune?: boolean;
        selfHeal?: boolean;
    }

    export interface GetGitopsApplicationsApplicationSpecSyncPolicyAutomatedArgs {
        allowEmpty?: pulumi.Input<boolean>;
        prune?: pulumi.Input<boolean>;
        selfHeal?: pulumi.Input<boolean>;
    }

    export interface GetGitopsApplicationsApplicationSpecSyncPolicyRetry {
        backoffs?: inputs.platform.GetGitopsApplicationsApplicationSpecSyncPolicyRetryBackoff[];
        limit?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSyncPolicyRetryArgs {
        backoffs?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsApplicationsApplicationSpecSyncPolicyRetryBackoffArgs>[]>;
        limit?: pulumi.Input<string>;
    }

    export interface GetGitopsApplicationsApplicationSpecSyncPolicyRetryBackoff {
        duration?: string;
        factor?: string;
        maxDuration?: string;
    }

    export interface GetGitopsApplicationsApplicationSpecSyncPolicyRetryBackoffArgs {
        duration?: pulumi.Input<string>;
        factor?: pulumi.Input<string>;
        maxDuration?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterQuery {
        /**
         * Cluster server URL or the cluster name.
         */
        ids?: inputs.platform.GetGitopsClusterQueryId[];
        /**
         * Name of the GitOps cluster.
         */
        name?: string;
        /**
         * Server of the GitOps cluster.
         */
        server?: string;
    }

    export interface GetGitopsClusterQueryArgs {
        /**
         * Cluster server URL or the cluster name.
         */
        ids?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterQueryIdArgs>[]>;
        /**
         * Name of the GitOps cluster.
         */
        name?: pulumi.Input<string>;
        /**
         * Server of the GitOps cluster.
         */
        server?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterQueryId {
        type?: string;
        value?: string;
    }

    export interface GetGitopsClusterQueryIdArgs {
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GetGitopsGnupgRequest {
        /**
         * Public key details.
         */
        publickeys?: inputs.platform.GetGitopsGnupgRequestPublickey[];
        /**
         * Indicates if the GnuPG Key should be inserted if not present or updated if present.
         */
        upsert?: boolean;
    }

    export interface GetGitopsGnupgRequestArgs {
        /**
         * Public key details.
         */
        publickeys?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsGnupgRequestPublickeyArgs>[]>;
        /**
         * Indicates if the GnuPG Key should be inserted if not present or updated if present.
         */
        upsert?: pulumi.Input<boolean>;
    }

    export interface GetGitopsGnupgRequestPublickey {
        fingerprint?: string;
        keyData?: string;
        keyId?: string;
        owner?: string;
        subType?: string;
        trust?: string;
    }

    export interface GetGitopsGnupgRequestPublickeyArgs {
        fingerprint?: pulumi.Input<string>;
        keyData?: pulumi.Input<string>;
        keyId?: pulumi.Input<string>;
        owner?: pulumi.Input<string>;
        subType?: pulumi.Input<string>;
        trust?: pulumi.Input<string>;
    }

    export interface GetGitopsRepoCredCred {
        /**
         * Specifies whether helm-oci support should be enabled for this repo.
         */
        enableOci?: boolean;
        /**
         * Specifies the GitHub API URL for GitHub app authentication.
         */
        githubAppEnterpriseBaseUrl?: string;
        /**
         * Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
         */
        githubAppId?: string;
        /**
         * Specifies the ID of the installed GitHub App for GitHub app authentication.
         */
        githubAppInstallationId?: string;
        /**
         * github*app*private_key specifies the private key PEM data for authentication via GitHub app.
         */
        githubAppPrivateKey?: string;
        /**
         * Password for authenticating at the repo server.
         */
        password?: string;
        /**
         * Contains the private key data for authenticating at the repo server using SSH (only Git repos).
         */
        sshPrivateKey?: string;
        /**
         * Specifies the TLS client cert data for authenticating at the repo server.
         */
        tlsClientCertData?: string;
        /**
         * Specifies the TLS client cert key for authenticating at the repo server.
         */
        tlsClientCertKey?: string;
        /**
         * Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
         */
        type?: string;
        /**
         * url representing this object.
         */
        url?: string;
        /**
         * Username for authenticating at the repo server.
         */
        username?: string;
    }

    export interface GetGitopsRepoCredCredArgs {
        /**
         * Specifies whether helm-oci support should be enabled for this repo.
         */
        enableOci?: pulumi.Input<boolean>;
        /**
         * Specifies the GitHub API URL for GitHub app authentication.
         */
        githubAppEnterpriseBaseUrl?: pulumi.Input<string>;
        /**
         * Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
         */
        githubAppId?: pulumi.Input<string>;
        /**
         * Specifies the ID of the installed GitHub App for GitHub app authentication.
         */
        githubAppInstallationId?: pulumi.Input<string>;
        /**
         * github*app*private_key specifies the private key PEM data for authentication via GitHub app.
         */
        githubAppPrivateKey?: pulumi.Input<string>;
        /**
         * Password for authenticating at the repo server.
         */
        password?: pulumi.Input<string>;
        /**
         * Contains the private key data for authenticating at the repo server using SSH (only Git repos).
         */
        sshPrivateKey?: pulumi.Input<string>;
        /**
         * Specifies the TLS client cert data for authenticating at the repo server.
         */
        tlsClientCertData?: pulumi.Input<string>;
        /**
         * Specifies the TLS client cert key for authenticating at the repo server.
         */
        tlsClientCertKey?: pulumi.Input<string>;
        /**
         * Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
         */
        type?: pulumi.Input<string>;
        /**
         * url representing this object.
         */
        url?: pulumi.Input<string>;
        /**
         * Username for authenticating at the repo server.
         */
        username?: pulumi.Input<string>;
    }

    export interface GetGitopsRepositoryUpdateMask {
        /**
         * The set of field mask paths.
         */
        paths?: string[];
    }

    export interface GetGitopsRepositoryUpdateMaskArgs {
        /**
         * The set of field mask paths.
         */
        paths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GetInputSetGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: string;
        /**
         * Name of the branch.
         */
        branchName?: string;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: string;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity.
         */
        connectorRef?: string;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: string;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: string;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: string;
        /**
         * Connector reference for Parent Entity (Pipeline).
         */
        parentEntityConnectorRef?: string;
        /**
         * Repository name for Parent Entity (Pipeline).
         */
        parentEntityRepoName?: string;
        /**
         * Name of the repository.
         */
        repoName?: string;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: string;
    }

    export interface GetInputSetGitDetailsArgs {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Connector reference for Parent Entity (Pipeline).
         */
        parentEntityConnectorRef?: pulumi.Input<string>;
        /**
         * Repository name for Parent Entity (Pipeline).
         */
        parentEntityRepoName?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface GetPipelineGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: string;
        /**
         * Name of the branch.
         */
        branchName?: string;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: string;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity.
         */
        connectorRef?: string;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: string;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: string;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: string;
        /**
         * Name of the repository.
         */
        repoName?: string;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: string;
    }

    export interface GetPipelineGitDetailsArgs {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface GetPolicySetPolicy {
        /**
         * Account Identifier of the account
         */
        identifier: string;
        /**
         * Policy failure response - 'warning' for continuation, 'error' for exit
         */
        severity: string;
    }

    export interface GetPolicySetPolicyArgs {
        /**
         * Account Identifier of the account
         */
        identifier: pulumi.Input<string>;
        /**
         * Policy failure response - 'warning' for continuation, 'error' for exit
         */
        severity: pulumi.Input<string>;
    }

    export interface GetTemplateGitDetails {
        /**
         * Name of the branch.
         */
        branchName?: string;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: string;
        /**
         * File url of the Entity in the repository.
         */
        fileUrl?: string;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: string;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: string;
        /**
         * Name of the repository.
         */
        repoName?: string;
        /**
         * Repo url of the Entity in the repository.
         */
        repoUrl?: string;
    }

    export interface GetTemplateGitDetailsArgs {
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * File url of the Entity in the repository.
         */
        fileUrl?: pulumi.Input<string>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Repo url of the Entity in the repository.
         */
        repoUrl?: pulumi.Input<string>;
    }

    export interface GetUsergroupNotificationConfig {
        /**
         * Group email.
         */
        groupEmail?: string;
        /**
         * Url of Microsoft teams webhook.
         */
        microsoftTeamsWebhookUrl?: string;
        /**
         * Pager duty key.
         */
        pagerDutyKey?: string;
        /**
         * Send email to all the group members.
         */
        sendEmailToAllUsers?: boolean;
        /**
         * Url of slack webhook.
         */
        slackWebhookUrl?: string;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
         */
        type?: string;
    }

    export interface GetUsergroupNotificationConfigArgs {
        /**
         * Group email.
         */
        groupEmail?: pulumi.Input<string>;
        /**
         * Url of Microsoft teams webhook.
         */
        microsoftTeamsWebhookUrl?: pulumi.Input<string>;
        /**
         * Pager duty key.
         */
        pagerDutyKey?: pulumi.Input<string>;
        /**
         * Send email to all the group members.
         */
        sendEmailToAllUsers?: pulumi.Input<boolean>;
        /**
         * Url of slack webhook.
         */
        slackWebhookUrl?: pulumi.Input<string>;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
         */
        type?: pulumi.Input<string>;
    }

    export interface GitConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.platform.GitConnectorCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.platform.GitConnectorCredentialsSsh>;
    }

    export interface GitConnectorCredentialsHttp {
        passwordRef: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface GitConnectorCredentialsSsh {
        sshKeyRef: pulumi.Input<string>;
    }

    export interface GitOpsAgentMetadata {
        /**
         * Indicates if the deployment should be deployed using the deploy-ha.yaml
         */
        highAvailability?: pulumi.Input<boolean>;
        /**
         * The k8s namespace that this agent resides in.
         */
        namespace?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplication {
        /**
         * Metadata corresponding to the resources. This includes all the objects a user must create.
         */
        metadatas: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationMetadata>[]>;
        /**
         * Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
         */
        specs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpec>[]>;
    }

    export interface GitOpsApplicationsApplicationMetadata {
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        clusterName?: pulumi.Input<string>;
        finalizers?: pulumi.Input<pulumi.Input<string>[]>;
        generateName?: pulumi.Input<string>;
        generation?: pulumi.Input<string>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        namespace?: pulumi.Input<string>;
        ownerReferences?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationMetadataOwnerReference>[]>;
        uid?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationMetadataOwnerReference {
        apiVersion?: pulumi.Input<string>;
        blockOwnerDeletion?: pulumi.Input<boolean>;
        controller?: pulumi.Input<boolean>;
        /**
         * Kind of the GitOps application.
         */
        kind?: pulumi.Input<string>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        uid?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpec {
        destinations?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecDestination>[]>;
        sources?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSource>[]>;
        syncPolicies?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSyncPolicy>[]>;
    }

    export interface GitOpsApplicationsApplicationSpecDestination {
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        namespace?: pulumi.Input<string>;
        server?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSource {
        chart?: pulumi.Input<string>;
        directories?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceDirectory>[]>;
        helms?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceHelm>[]>;
        ksonnets?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceKsonnet>[]>;
        kustomizes?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceKustomize>[]>;
        path: pulumi.Input<string>;
        plugins?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourcePlugin>[]>;
        repoUrl: pulumi.Input<string>;
        targetRevision: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceDirectory {
        exclude?: pulumi.Input<string>;
        include?: pulumi.Input<string>;
        jsonnets?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnet>[]>;
        recurse?: pulumi.Input<boolean>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceDirectoryJsonnet {
        extVars?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar>[]>;
        libs?: pulumi.Input<pulumi.Input<string>[]>;
        tlas?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTla>[]>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar {
        code?: pulumi.Input<boolean>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTla {
        code?: pulumi.Input<boolean>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceHelm {
        fileParameters?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceHelmFileParameter>[]>;
        parameters?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceHelmParameter>[]>;
        passCredentials?: pulumi.Input<boolean>;
        releaseName?: pulumi.Input<string>;
        valueFiles?: pulumi.Input<pulumi.Input<string>[]>;
        values?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceHelmFileParameter {
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceHelmParameter {
        forceString?: pulumi.Input<boolean>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceKsonnet {
        environment?: pulumi.Input<string>;
        parameters?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceKsonnetParameter>[]>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceKsonnetParameter {
        component?: pulumi.Input<string>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceKustomize {
        commonAnnotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        commonLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        forceCommonAnnotations?: pulumi.Input<boolean>;
        forceCommonLabels?: pulumi.Input<boolean>;
        images?: pulumi.Input<pulumi.Input<string>[]>;
        namePrefix?: pulumi.Input<string>;
        nameSuffix?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourcePlugin {
        envs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourcePluginEnv>[]>;
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourcePluginEnv {
        /**
         * Name of the GitOps application.
         */
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSyncPolicy {
        automateds?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSyncPolicyAutomated>[]>;
        retries?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSyncPolicyRetry>[]>;
        syncOptions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GitOpsApplicationsApplicationSpecSyncPolicyAutomated {
        allowEmpty?: pulumi.Input<boolean>;
        prune?: pulumi.Input<boolean>;
        selfHeal?: pulumi.Input<boolean>;
    }

    export interface GitOpsApplicationsApplicationSpecSyncPolicyRetry {
        backoffs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoff>[]>;
        limit?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoff {
        duration?: pulumi.Input<string>;
        factor?: pulumi.Input<string>;
        maxDuration?: pulumi.Input<string>;
    }

    export interface GitOpsClusterQuery {
        /**
         * Cluster server URL or the cluster name.
         */
        ids?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterQueryId>[]>;
        /**
         * Name of the GitOps cluster.
         */
        name?: pulumi.Input<string>;
        /**
         * Server of the GitOps cluster.
         */
        server?: pulumi.Input<string>;
    }

    export interface GitOpsClusterQueryId {
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequest {
        /**
         * GitOps cluster details.
         */
        clusters?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestCluster>[]>;
        /**
         * Cluster server URL or the cluster name.
         */
        ids?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestId>[]>;
        /**
         * Tags associated with the clusters
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Update mask of the GitOps cluster.
         */
        updateMasks?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestUpdateMask>[]>;
        /**
         * Fields which are updated.
         */
        updatedFields?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Indicates if the GitOps cluster should be updated if existing and inserted if not.
         */
        upsert?: pulumi.Input<boolean>;
    }

    export interface GitOpsClusterRequestCluster {
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        clusterResources?: pulumi.Input<boolean>;
        configs: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterConfig>[]>;
        infos?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterInfo>[]>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        name?: pulumi.Input<string>;
        namespaces?: pulumi.Input<pulumi.Input<string>[]>;
        project?: pulumi.Input<string>;
        refreshRequestedAts?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterRefreshRequestedAt>[]>;
        server: pulumi.Input<string>;
        shard?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterConfig {
        awsAuthConfigs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterConfigAwsAuthConfig>[]>;
        bearerToken?: pulumi.Input<string>;
        clusterConnectionType?: pulumi.Input<string>;
        execProviderConfigs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterConfigExecProviderConfig>[]>;
        password?: pulumi.Input<string>;
        tlsClientConfigs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterConfigTlsClientConfig>[]>;
        username?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterConfigAwsAuthConfig {
        clusterName?: pulumi.Input<string>;
        roleARN?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterConfigExecProviderConfig {
        apiVersion?: pulumi.Input<string>;
        args?: pulumi.Input<pulumi.Input<string>[]>;
        command?: pulumi.Input<string>;
        env?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        installHint?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterConfigTlsClientConfig {
        caData?: pulumi.Input<string>;
        certData?: pulumi.Input<string>;
        insecure?: pulumi.Input<boolean>;
        keyData?: pulumi.Input<string>;
        serverName?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterInfo {
        apiVersions?: pulumi.Input<pulumi.Input<string>[]>;
        applicationsCount?: pulumi.Input<string>;
        cacheInfos?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterInfoCacheInfo>[]>;
        connectionStates?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterInfoConnectionState>[]>;
        serverVersion?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterInfoCacheInfo {
        apisCount?: pulumi.Input<string>;
        lastCacheSyncTime?: pulumi.Input<string>;
        resourcesCount?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterInfoConnectionState {
        attemptedAts?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterInfoConnectionStateAttemptedAt>[]>;
        message?: pulumi.Input<string>;
        status?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterInfoConnectionStateAttemptedAt {
        nanos?: pulumi.Input<number>;
        seconds?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterRefreshRequestedAt {
        nanos?: pulumi.Input<number>;
        seconds?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestId {
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestUpdateMask {
        paths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GitOpsGnupgRequest {
        /**
         * Public key details.
         */
        publickeys?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsGnupgRequestPublickey>[]>;
        /**
         * Indicates if the GnuPG Key should be inserted if not present or updated if present.
         */
        upsert: pulumi.Input<boolean>;
    }

    export interface GitOpsGnupgRequestPublickey {
        fingerprint?: pulumi.Input<string>;
        keyData: pulumi.Input<string>;
        keyId?: pulumi.Input<string>;
        owner?: pulumi.Input<string>;
        subType?: pulumi.Input<string>;
        trust?: pulumi.Input<string>;
    }

    export interface GitOpsRepoCertRequest {
        /**
         * certificates details.
         */
        certificates?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsRepoCertRequestCertificate>[]>;
        /**
         * if the Repository Certificates should be upserted.
         */
        upsert?: pulumi.Input<boolean>;
    }

    export interface GitOpsRepoCertRequestCertificate {
        items?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsRepoCertRequestCertificateItem>[]>;
        metadatas?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsRepoCertRequestCertificateMetadata>[]>;
    }

    export interface GitOpsRepoCertRequestCertificateItem {
        certData?: pulumi.Input<string>;
        certInfo?: pulumi.Input<string>;
        certSubType?: pulumi.Input<string>;
        certType?: pulumi.Input<string>;
        serverName?: pulumi.Input<string>;
    }

    export interface GitOpsRepoCertRequestCertificateMetadata {
        continue?: pulumi.Input<string>;
        remainingItemCount?: pulumi.Input<string>;
        resourceVersion?: pulumi.Input<string>;
        selfLink?: pulumi.Input<string>;
    }

    export interface GitOpsRepoCredCred {
        /**
         * Specifies whether helm-oci support should be enabled for this repo.
         */
        enableOci?: pulumi.Input<boolean>;
        /**
         * Specifies the GitHub API URL for GitHub app authentication.
         */
        githubAppEnterpriseBaseUrl?: pulumi.Input<string>;
        /**
         * Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
         */
        githubAppId?: pulumi.Input<string>;
        /**
         * Specifies the ID of the installed GitHub App for GitHub app authentication.
         */
        githubAppInstallationId?: pulumi.Input<string>;
        /**
         * github*app*private_key specifies the private key PEM data for authentication via GitHub app.
         */
        githubAppPrivateKey?: pulumi.Input<string>;
        /**
         * Password for authenticating at the repo server.
         */
        password?: pulumi.Input<string>;
        /**
         * Contains the private key data for authenticating at the repo server using SSH (only Git repos).
         */
        sshPrivateKey?: pulumi.Input<string>;
        /**
         * Specifies the TLS client cert data for authenticating at the repo server.
         */
        tlsClientCertData?: pulumi.Input<string>;
        /**
         * Specifies the TLS client cert key for authenticating at the repo server.
         */
        tlsClientCertKey?: pulumi.Input<string>;
        /**
         * Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
         */
        type?: pulumi.Input<string>;
        /**
         * url representing this object.
         */
        url?: pulumi.Input<string>;
        /**
         * Username for authenticating at the repo server.
         */
        username?: pulumi.Input<string>;
    }

    export interface GitOpsRepositoryRepo {
        /**
         * Identifies the authentication method used to connect to the repository.
         */
        connectionType: pulumi.Input<string>;
        /**
         * Indicates if git-lfs support must be enabled for this repo. This is valid only for Git repositories.
         */
        enableLfs?: pulumi.Input<boolean>;
        /**
         * Indicates if helm-oci support must be enabled for this repo.
         */
        enableOci?: pulumi.Input<boolean>;
        /**
         * Base URL of GitHub Enterprise installation. If left empty, this defaults to https://api.github.com.
         */
        githubAppEnterpriseBaseUrl?: pulumi.Input<string>;
        /**
         * Id of the GitHub app used to access the repo.
         */
        githubAppId?: pulumi.Input<string>;
        /**
         * Installation id of the GitHub app used to access the repo.
         */
        githubAppInstallationId?: pulumi.Input<string>;
        /**
         * GitHub app private key PEM data.
         */
        githubAppPrivateKey?: pulumi.Input<string>;
        /**
         * Indicates if the credentials were inherited from a credential set.
         */
        inheritedCreds?: pulumi.Input<boolean>;
        /**
         * Indicates if the connection to the repository ignores any errors when verifying TLS certificates or SSH host keys.
         */
        insecure?: pulumi.Input<boolean>;
        /**
         * Indicates if InsecureIgnoreHostKey should be used. Insecure is favored used only for git repos.
         */
        insecureIgnoreHostKey?: pulumi.Input<boolean>;
        /**
         * Name to be used for this repo. Only used with Helm repos.
         */
        name?: pulumi.Input<string>;
        /**
         * Password or PAT used for authenticating at the remote repository.
         */
        password?: pulumi.Input<string>;
        /**
         * Reference between project and repository that allow you automatically to be added as item inside SourceRepos project entity.
         */
        project?: pulumi.Input<string>;
        /**
         * The HTTP/HTTPS proxy used to access the repo.
         */
        proxy?: pulumi.Input<string>;
        /**
         * URL to the remote repository.
         */
        repo: pulumi.Input<string>;
        /**
         * PEM data for authenticating at the repo server. Only used with Git repos.
         */
        sshPrivateKey?: pulumi.Input<string>;
        /**
         * Certificate in PEM format for authenticating at the repo server.
         */
        tlsClientCertData?: pulumi.Input<string>;
        /**
         * Private key in PEM format for authenticating at the repo server.
         */
        tlsClientCertKey?: pulumi.Input<string>;
        /**
         * Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.
         */
        type_?: pulumi.Input<string>;
        /**
         * Username used for authenticating at the remote repository.
         */
        username?: pulumi.Input<string>;
    }

    export interface GitOpsRepositoryUpdateMask {
        /**
         * The set of field mask paths.
         */
        paths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GithubConnectorApiAuthentication {
        /**
         * Configuration for using the github app for interacting with the github api.
         */
        githubApp?: pulumi.Input<inputs.platform.GithubConnectorApiAuthenticationGithubApp>;
        /**
         * Personal access token for interacting with the github api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        tokenRef?: pulumi.Input<string>;
    }

    export interface GithubConnectorApiAuthenticationGithubApp {
        applicationId?: pulumi.Input<string>;
        applicationIdRef?: pulumi.Input<string>;
        installationId?: pulumi.Input<string>;
        installationIdRef?: pulumi.Input<string>;
        privateKeyRef: pulumi.Input<string>;
    }

    export interface GithubConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.platform.GithubConnectorCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.platform.GithubConnectorCredentialsSsh>;
    }

    export interface GithubConnectorCredentialsHttp {
        tokenRef: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface GithubConnectorCredentialsSsh {
        sshKeyRef: pulumi.Input<string>;
    }

    export interface GitlabConnectorApiAuthentication {
        /**
         * Personal access token for interacting with the gitlab api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        tokenRef: pulumi.Input<string>;
    }

    export interface GitlabConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.platform.GitlabConnectorCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.platform.GitlabConnectorCredentialsSsh>;
    }

    export interface GitlabConnectorCredentialsHttp {
        passwordRef?: pulumi.Input<string>;
        tokenRef?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface GitlabConnectorCredentialsSsh {
        sshKeyRef: pulumi.Input<string>;
    }

    export interface HelmConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface InputSetGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Connector reference for Parent Entity (Pipeline). To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        parentEntityConnectorRef?: pulumi.Input<string>;
        /**
         * Repository name for Parent Entity (Pipeline).
         */
        parentEntityRepoName?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface JenkinsConnectorAuth {
        /**
         * Authenticate to App Dynamics using bearer token.
         */
        jenkinsBearerToken?: pulumi.Input<inputs.platform.JenkinsConnectorAuthJenkinsBearerToken>;
        /**
         * Authenticate to App Dynamics using user name and password.
         */
        jenkinsUserNamePassword?: pulumi.Input<inputs.platform.JenkinsConnectorAuthJenkinsUserNamePassword>;
        /**
         * Can be one of UsernamePassword, Anonymous, Bearer Token(HTTP Header)
         */
        type: pulumi.Input<string>;
    }

    export interface JenkinsConnectorAuthJenkinsBearerToken {
        tokenRef: pulumi.Input<string>;
    }

    export interface JenkinsConnectorAuthJenkinsUserNamePassword {
        passwordRef: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface JiraConnectorAuth {
        /**
         * Authentication types for Jira connector
         */
        authType: pulumi.Input<string>;
        /**
         * Authenticate using username password.
         */
        usernamePassword?: pulumi.Input<inputs.platform.JiraConnectorAuthUsernamePassword>;
    }

    export interface JiraConnectorAuthUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface KubernetesConnectorClientKeyCert {
        /**
         * Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        caCertRef?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the client certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientCertRef: pulumi.Input<string>;
        /**
         * The algorithm used to generate the client key for the connector. Valid values are RSA, EC
         */
        clientKeyAlgorithm: pulumi.Input<string>;
        /**
         * Reference to the secret containing the client key passphrase for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientKeyPassphraseRef?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the client key for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientKeyRef: pulumi.Input<string>;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
    }

    export interface KubernetesConnectorInheritFromDelegate {
        /**
         * Selectors to use for the delegate.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface KubernetesConnectorOpenidConnect {
        /**
         * Reference to the secret containing the client ID for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientIdRef: pulumi.Input<string>;
        /**
         * The URL of the OpenID Connect issuer.
         */
        issuerUrl: pulumi.Input<string>;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Scopes to request for the connector.
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Reference to the secret containing the client secret for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        secretRef?: pulumi.Input<string>;
        /**
         * Username for the connector.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface KubernetesConnectorServiceAccount {
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Reference to the secret containing the service account token for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        serviceAccountTokenRef: pulumi.Input<string>;
    }

    export interface KubernetesConnectorUsernamePassword {
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username for the connector.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface ManualFreezeCurrentOrUpcomingWindow {
        /**
         * End time of the freeze
         */
        endTime?: pulumi.Input<number>;
        /**
         * Start time of the freeze
         */
        startTime?: pulumi.Input<number>;
    }

    export interface ManualFreezeFreezeWindow {
        /**
         * Duration of the freeze
         */
        duration?: pulumi.Input<string>;
        /**
         * End time of the freeze
         */
        endTime?: pulumi.Input<string>;
        recurrences?: pulumi.Input<pulumi.Input<inputs.platform.ManualFreezeFreezeWindowRecurrence>[]>;
        /**
         * Start time of the freeze
         */
        startTime?: pulumi.Input<string>;
        /**
         * Timezone
         */
        timeZone?: pulumi.Input<string>;
    }

    export interface ManualFreezeFreezeWindowRecurrence {
        recurrenceSpecs?: pulumi.Input<pulumi.Input<inputs.platform.ManualFreezeFreezeWindowRecurrenceRecurrenceSpec>[]>;
        /**
         * Type of freeze
         */
        type?: pulumi.Input<string>;
    }

    export interface ManualFreezeFreezeWindowRecurrenceRecurrenceSpec {
        until?: pulumi.Input<string>;
        value?: pulumi.Input<number>;
    }

    export interface MonitoredServiceRequest {
        /**
         * Set of change sources for the monitored service.
         */
        changeSources?: pulumi.Input<pulumi.Input<inputs.platform.MonitoredServiceRequestChangeSource>[]>;
        /**
         * Dependencies of the monitored service.
         */
        dependencies?: pulumi.Input<pulumi.Input<inputs.platform.MonitoredServiceRequestDependency>[]>;
        /**
         * Description for the monitored service.
         */
        description?: pulumi.Input<string>;
        /**
         * Enable or disable the monitored service.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Environment in which the service is deployed.
         */
        environmentRef: pulumi.Input<string>;
        /**
         * Environment reference list for the monitored service.
         */
        environmentRefLists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Set of health sources for the monitored service.
         */
        healthSources?: pulumi.Input<pulumi.Input<inputs.platform.MonitoredServiceRequestHealthSource>[]>;
        /**
         * Name for the monitored service.
         */
        name: pulumi.Input<string>;
        /**
         * Notification rule references for the monitored service.
         */
        notificationRuleRefs?: pulumi.Input<pulumi.Input<inputs.platform.MonitoredServiceRequestNotificationRuleRef>[]>;
        /**
         * Service reference for the monitored service.
         */
        serviceRef: pulumi.Input<string>;
        /**
         * Tags for the monitored service. comma-separated key value string pairs.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Template reference for the monitored service.
         */
        templateRef?: pulumi.Input<string>;
        /**
         * Type of the monitored service.
         */
        type: pulumi.Input<string>;
        /**
         * Template version label for the monitored service.
         */
        versionLabel?: pulumi.Input<string>;
    }

    export interface MonitoredServiceRequestChangeSource {
        category: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        /**
         * Identifier of the monitored service.
         */
        identifier: pulumi.Input<string>;
        name: pulumi.Input<string>;
        spec?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface MonitoredServiceRequestDependency {
        dependencyMetadata?: pulumi.Input<string>;
        monitoredServiceIdentifier: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface MonitoredServiceRequestHealthSource {
        /**
         * Identifier of the monitored service.
         */
        identifier: pulumi.Input<string>;
        name: pulumi.Input<string>;
        spec: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface MonitoredServiceRequestNotificationRuleRef {
        enabled: pulumi.Input<boolean>;
        notificationRuleRef: pulumi.Input<string>;
    }

    export interface NexusConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface OciHelmConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface PipelineFiltersFilterProperties {
        /**
         * Corresponding Entity of the filters. Currently supported types are {Connector, DelegateProfile, Delegate, PipelineSetup, PipelineExecution, Deployment, Audit, Template, EnvironmentGroup, FileStore, CCMRecommendation, Anomaly, Environment}.
         */
        filterType: pulumi.Input<string>;
        /**
         * Tags to associate with the resource. Tags should be in the form `name:value`.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PipelineGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface PolicySetPolicy {
        /**
         * Account Identifier of the account
         */
        identifier: pulumi.Input<string>;
        /**
         * Policy failure response - 'warning' for continuation, 'error' for exit
         */
        severity: pulumi.Input<string>;
    }

    export interface PrometheusConnectorHeader {
        /**
         * Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        encryptedValueRef?: pulumi.Input<string>;
        /**
         * Key.
         */
        key: pulumi.Input<string>;
        /**
         * Value.
         */
        value?: pulumi.Input<string>;
        /**
         * Encrypted value.
         */
        valueEncrypted?: pulumi.Input<boolean>;
    }

    export interface ResourceGroupIncludedScope {
        /**
         * Account Identifier of the account
         */
        accountId?: pulumi.Input<string>;
        /**
         * Can be one of these 2 EXCLUDING*CHILD*SCOPES or INCLUDING*CHILD*SCOPES
         */
        filter: pulumi.Input<string>;
        /**
         * Organization Identifier
         */
        orgId?: pulumi.Input<string>;
        /**
         * Project Identifier
         */
        projectId?: pulumi.Input<string>;
    }

    export interface ResourceGroupResourceFilter {
        /**
         * Include all resource or not
         */
        includeAllResources?: pulumi.Input<boolean>;
        /**
         * Resources for a resource group
         */
        resources?: pulumi.Input<pulumi.Input<inputs.platform.ResourceGroupResourceFilterResource>[]>;
    }

    export interface ResourceGroupResourceFilterResource {
        attributeFilters?: pulumi.Input<pulumi.Input<inputs.platform.ResourceGroupResourceFilterResourceAttributeFilter>[]>;
        identifiers?: pulumi.Input<pulumi.Input<string>[]>;
        resourceType: pulumi.Input<string>;
    }

    export interface ResourceGroupResourceFilterResourceAttributeFilter {
        attributeName?: pulumi.Input<string>;
        attributeValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RoleAssignmentsPrincipal {
        /**
         * Identifier.
         */
        identifier?: pulumi.Input<string>;
        /**
         * Scope level.
         */
        scopeLevel?: pulumi.Input<string>;
        /**
         * Type.
         */
        type: pulumi.Input<string>;
    }

    export interface SecretSshkeyKerberos {
        /**
         * Username to use for authentication.
         */
        principal: pulumi.Input<string>;
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        realm: pulumi.Input<string>;
        /**
         * Method to generate tgt
         */
        tgtGenerationMethod?: pulumi.Input<string>;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtKeyTabFilePathSpec?: pulumi.Input<inputs.platform.SecretSshkeyKerberosTgtKeyTabFilePathSpec>;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtPasswordSpec?: pulumi.Input<inputs.platform.SecretSshkeyKerberosTgtPasswordSpec>;
    }

    export interface SecretSshkeyKerberosTgtKeyTabFilePathSpec {
        keyPath?: pulumi.Input<string>;
    }

    export interface SecretSshkeyKerberosTgtPasswordSpec {
        password?: pulumi.Input<string>;
    }

    export interface SecretSshkeySsh {
        /**
         * This specifies SSH credential type as Password, KeyPath or KeyReference
         */
        credentialType: pulumi.Input<string>;
        /**
         * SSH credential of type keyReference
         */
        sshPasswordCredential?: pulumi.Input<inputs.platform.SecretSshkeySshSshPasswordCredential>;
        /**
         * SSH credential of type keyPath
         */
        sshkeyPathCredential?: pulumi.Input<inputs.platform.SecretSshkeySshSshkeyPathCredential>;
        /**
         * SSH credential of type keyReference
         */
        sshkeyReferenceCredential?: pulumi.Input<inputs.platform.SecretSshkeySshSshkeyReferenceCredential>;
    }

    export interface SecretSshkeySshSshPasswordCredential {
        password: pulumi.Input<string>;
        userName: pulumi.Input<string>;
    }

    export interface SecretSshkeySshSshkeyPathCredential {
        encryptedPassphrase?: pulumi.Input<string>;
        keyPath: pulumi.Input<string>;
        userName: pulumi.Input<string>;
    }

    export interface SecretSshkeySshSshkeyReferenceCredential {
        encryptedPassphrase?: pulumi.Input<string>;
        key: pulumi.Input<string>;
        userName: pulumi.Input<string>;
    }

    export interface ServiceNowConnectorAuth {
        /**
         * Authenticate using adfs client credentials with certificate.
         */
        adfs?: pulumi.Input<inputs.platform.ServiceNowConnectorAuthAdfs>;
        /**
         * Authentication types for Jira connector
         */
        authType: pulumi.Input<string>;
        /**
         * Authenticate using username password.
         */
        usernamePassword?: pulumi.Input<inputs.platform.ServiceNowConnectorAuthUsernamePassword>;
    }

    export interface ServiceNowConnectorAuthAdfs {
        adfsUrl: pulumi.Input<string>;
        certificateRef: pulumi.Input<string>;
        clientIdRef: pulumi.Input<string>;
        privateKeyRef: pulumi.Input<string>;
        resourceIdRef: pulumi.Input<string>;
    }

    export interface ServiceNowConnectorAuthUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface SloRequest {
        /**
         * Description for the SLO.
         */
        description?: pulumi.Input<string>;
        /**
         * Name for the SLO.
         */
        name: pulumi.Input<string>;
        /**
         * Notification rule references for the SLO.
         */
        notificationRuleRefs?: pulumi.Input<pulumi.Input<inputs.platform.SloRequestNotificationRuleRef>[]>;
        /**
         * SLO Target specification.
         */
        sloTarget: pulumi.Input<inputs.platform.SloRequestSloTarget>;
        /**
         * Specification of the SLO.
         */
        spec: pulumi.Input<string>;
        /**
         * Tags for the SLO. comma-separated key value string pairs.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Type of the SLO.
         */
        type: pulumi.Input<string>;
        /**
         * User journey reference list for the SLO.
         */
        userJourneyRefs: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SloRequestNotificationRuleRef {
        enabled: pulumi.Input<boolean>;
        notificationRuleRef: pulumi.Input<string>;
    }

    export interface SloRequestSloTarget {
        sloTargetPercentage: pulumi.Input<number>;
        spec: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface SpotConnectorPermanentToken {
        /**
         * Reference to the Harness secret containing the permanent api token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        apiTokenRef: pulumi.Input<string>;
        /**
         * Connect only using delegates with these tags.
         */
        delegateSelectors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Execute on delegate or not.
         */
        executeOnDelegate?: pulumi.Input<boolean>;
        /**
         * Spot account id.
         */
        spotAccountId?: pulumi.Input<string>;
        /**
         * Reference to the Harness secret containing the spot account id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        spotAccountIdRef?: pulumi.Input<string>;
    }

    export interface TasConnectorCredentials {
        /**
         * Authenticate to Tas using manual details.
         */
        tasManualDetails: pulumi.Input<inputs.platform.TasConnectorCredentialsTasManualDetails>;
        /**
         * Type can be ManualConfig.
         */
        type: pulumi.Input<string>;
    }

    export interface TasConnectorCredentialsTasManualDetails {
        endpointUrl: pulumi.Input<string>;
        passwordRef: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface TemplateFiltersFilterProperties {
        /**
         * Corresponding Entity of the filters. Currently supported types are {TemplateSetup, TemplateExecution, Template}.
         */
        filterType: pulumi.Input<string>;
        /**
         * Tags to associate with the resource. Tags should be in the form `name:value`.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface TerraformCloudConnectorCredentials {
        /**
         * API token credentials to use for authentication.
         */
        apiToken: pulumi.Input<inputs.platform.TerraformCloudConnectorCredentialsApiToken>;
    }

    export interface TerraformCloudConnectorCredentialsApiToken {
        apiTokenRef: pulumi.Input<string>;
    }

    export interface UserRoleBinding {
        /**
         * Managed Role of the user.
         */
        managedRole?: pulumi.Input<boolean>;
        /**
         * Resource Group Identifier of the user.
         */
        resourceGroupIdentifier?: pulumi.Input<string>;
        /**
         * Resource Group Name of the user.
         */
        resourceGroupName?: pulumi.Input<string>;
        /**
         * Role Identifier of the user.
         */
        roleIdentifier?: pulumi.Input<string>;
        /**
         * Role Name Identifier of the user.
         */
        roleName?: pulumi.Input<string>;
    }

    export interface UsergroupNotificationConfig {
        /**
         * Group email.
         */
        groupEmail?: pulumi.Input<string>;
        /**
         * Url of Microsoft teams webhook.
         */
        microsoftTeamsWebhookUrl?: pulumi.Input<string>;
        /**
         * Pager duty key.
         */
        pagerDutyKey?: pulumi.Input<string>;
        /**
         * Send email to all the group members.
         */
        sendEmailToAllUsers?: pulumi.Input<boolean>;
        /**
         * Url of slack webhook.
         */
        slackWebhookUrl?: pulumi.Input<string>;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
         */
        type?: pulumi.Input<string>;
    }

    export interface VariablesSpec {
        /**
         * FixedValue of the variable
         */
        fixedValue: pulumi.Input<string>;
        /**
         * Type of Value of the Variable. For now only FIXED is supported
         */
        valueType: pulumi.Input<string>;
    }
}

export namespace service {
    export interface AmiVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface CodedeployVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface EcsVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface HelmVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface KubernetesVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface LambdaVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface SshVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface TanzuVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface WinrmVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }
}
