// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface EncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface EnvironmentVariableOverride {
    /**
     * The name of the variable
     */
    name: pulumi.Input<string>;
    /**
     * The name of the service
     */
    serviceName?: pulumi.Input<string>;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type: pulumi.Input<string>;
    /**
     * The value of the service variable
     */
    value: pulumi.Input<string>;
}

export interface GetEncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetEncryptedTextUsageScopeArgs {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface GetSecretManagerUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetSecretManagerUsageScopeArgs {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface GetSshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetSshCredentialUsageScopeArgs {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface GitConnectorCommitDetails {
    /**
     * The email id of the author
     */
    authorEmailId?: pulumi.Input<string>;
    /**
     * The name of the author
     */
    authorName?: pulumi.Input<string>;
    /**
     * Commit message
     */
    message?: pulumi.Input<string>;
}

export interface GitConnectorUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsAmi {
    /**
     * The ami deployment type to use. Valid options are AWS_ASG, SPOTINST
     */
    amiDeploymentType: pulumi.Input<string>;
    /**
     * Flag to indicate whether the autoscaling group identifies the workload.
     */
    asgIdentifiesWorkload?: pulumi.Input<boolean>;
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: pulumi.Input<string>;
    /**
     * The classic load balancers to use.
     */
    classicLoadbalancers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The name of the SpotInst cloud provider to connect with.
     */
    spotinstCloudProviderName?: pulumi.Input<string>;
    /**
     * The SpotInst configuration to use.
     */
    spotinstConfigJson?: pulumi.Input<string>;
    /**
     * The staging classic load balancers to use.
     */
    stageClassicLoadbalancers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The staging classic load balancers to use.
     */
    stageTargetGroupArns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ARN's of the target groups.
     */
    targetGroupArns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Flag to enable traffic shifting.
     */
    useTrafficShift?: pulumi.Input<boolean>;
}

export interface InfrastructureDefinitionAwsEcs {
    /**
     * Flag to assign a public IP address.
     */
    assignPublicIp?: pulumi.Input<boolean>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the ECS cluster to use.
     */
    clusterName: pulumi.Input<string>;
    /**
     * The ARN of the role to use for execution.
     */
    executionRole?: pulumi.Input<string>;
    /**
     * The type of launch configuration to use. Valid options are FARGATE
     */
    launchType: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsLambda {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The IAM role to use.
     */
    iamRole?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsSsh {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: pulumi.Input<string>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The desired capacity of the auto scaling group.
     */
    desiredCapacity?: pulumi.Input<number>;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: pulumi.Input<string>;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: pulumi.Input<string>;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: pulumi.Input<string>;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The tags to use when selecting the instances.
     */
    tags?: pulumi.Input<pulumi.Input<inputs.InfrastructureDefinitionAwsSshTag>[]>;
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InfrastructureDefinitionAwsSshTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsWinrm {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName: pulumi.Input<string>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The desired capacity of the autoscaling group.
     */
    desiredCapacity?: pulumi.Input<number>;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName: pulumi.Input<string>;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: pulumi.Input<string>;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: pulumi.Input<string>;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAzureVmss {
    /**
     * The type of authentication to use. Valid options are SSH*PUBLIC*KEY.
     */
    authType: pulumi.Input<string>;
    /**
     * Base name.
     */
    baseName: pulumi.Input<string>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The type of deployment. Valid options are NATIVE_VMSS
     */
    deploymentType: pulumi.Input<string>;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: pulumi.Input<string>;
    /**
     * The name of the resource group.
     */
    resourceGroupName: pulumi.Input<string>;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: pulumi.Input<string>;
    /**
     * The username to connect with.
     */
    username: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAzureWebapp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the resource group.
     */
    resourceGroup: pulumi.Input<string>;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: pulumi.Input<string>;
}

export interface InfrastructureDefinitionDatacenterSsh {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the SSH connection attributes to use.
     */
    hostConnectionAttributesName: pulumi.Input<string>;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InfrastructureDefinitionDatacenterWinrm {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the WinRM connection attributes to use.
     */
    winrmConnectionAttributesName: pulumi.Input<string>;
}

export interface InfrastructureDefinitionKubernetes {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: pulumi.Input<string>;
    /**
     * The naming convention of the release. When using Helm Native the default is ${infra.kubernetes.infraId}. For standard Kubernetes manifests the default is release-${infra.kubernetes.infraId}
     */
    releaseName: pulumi.Input<string>;
}

export interface InfrastructureDefinitionKubernetesGcp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the cluster being deployed to.
     */
    clusterName: pulumi.Input<string>;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: pulumi.Input<string>;
    /**
     * The naming convention of the release.
     */
    releaseName: pulumi.Input<string>;
}

export interface InfrastructureDefinitionTanzu {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The PCF organization to use.
     */
    organization: pulumi.Input<string>;
    /**
     * The PCF space to deploy to.
     */
    space: pulumi.Input<string>;
}

export interface SshCredentialKerberosAuthentication {
    /**
     * Port to use for Kerberos authentication
     */
    port: pulumi.Input<number>;
    /**
     * Name of the principal for authentication
     */
    principal: pulumi.Input<string>;
    /**
     * Realm associated with the Kerberos authentication
     */
    realm: pulumi.Input<string>;
    /**
     * TGT generation method
     */
    tgtGenerationMethod?: pulumi.Input<inputs.SshCredentialKerberosAuthenticationTgtGenerationMethod>;
}

export interface SshCredentialKerberosAuthenticationTgtGenerationMethod {
    kerberosPasswordId?: pulumi.Input<string>;
    keyTabFilePath?: pulumi.Input<string>;
}

export interface SshCredentialSshAuthentication {
    /**
     * Inline SSH authentication configuration. Only ond of `passphraseSecretId` or `sshKeyFileId` should be used
     */
    inlineSsh?: pulumi.Input<inputs.SshCredentialSshAuthenticationInlineSsh>;
    /**
     * The port to connect to
     */
    port: pulumi.Input<number>;
    /**
     * Server password authentication configuration
     */
    serverPassword?: pulumi.Input<inputs.SshCredentialSshAuthenticationServerPassword>;
    /**
     * Use ssh key file for authentication
     */
    sshKeyFile?: pulumi.Input<inputs.SshCredentialSshAuthenticationSshKeyFile>;
    /**
     * The username to use when connecting to ssh
     */
    username: pulumi.Input<string>;
}

export interface SshCredentialSshAuthenticationInlineSsh {
    passphraseSecretId?: pulumi.Input<string>;
    sshKeyFileId: pulumi.Input<string>;
}

export interface SshCredentialSshAuthenticationServerPassword {
    passwordSecretId: pulumi.Input<string>;
}

export interface SshCredentialSshAuthenticationSshKeyFile {
    passphraseSecretId?: pulumi.Input<string>;
    path: pulumi.Input<string>;
}

export interface SshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface UserGroupLdapSettings {
    /**
     * The group DN of the LDAP user group.
     */
    groupDn?: pulumi.Input<string>;
    /**
     * The group name of the LDAP user group.
     */
    groupName?: pulumi.Input<string>;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: pulumi.Input<string>;
}

export interface UserGroupNotificationSettings {
    /**
     * The email addresses of the user group.
     */
    groupEmailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The Microsoft Teams webhook URL of the user group.
     */
    microsoftTeamsWebhookUrl?: pulumi.Input<string>;
    /**
     * Indicates whether an email is sent when a new user is added to the group.
     */
    sendMailToNewMembers?: pulumi.Input<boolean>;
    /**
     * Enable this setting to have notifications sent to the members of this group.
     */
    sendNotificationsToMembers?: pulumi.Input<boolean>;
    /**
     * The Slack channel to send notifications to.
     */
    slackChannel?: pulumi.Input<string>;
    /**
     * The Slack webhook URL to send notifications to.
     */
    slackWebhookUrl?: pulumi.Input<string>;
}

export interface UserGroupPermissions {
    /**
     * The account permissions of the user group. Valid options are ADMINISTER*OTHER*ACCOUNT*FUNCTIONS, CREATE*AND*DELETE*APPLICATION, CREATE*CUSTOM*DASHBOARDS, MANAGE*ALERT*NOTIFICATION*RULES, MANAGE*API*KEYS, MANAGE*APPLICATION*STACKS, MANAGE*AUTHENTICATION*SETTINGS, MANAGE*CLOUD*PROVIDERS, MANAGE*CONFIG*AS*CODE, MANAGE*CONNECTORS, MANAGE*CUSTOM*DASHBOARDS, MANAGE*DELEGATE*PROFILES, MANAGE*DELEGATES, MANAGE*DEPLOYMENT*FREEZES, MANAGE*IP*WHITELIST, MANAGE*PIPELINE*GOVERNANCE*STANDARDS, MANAGE*RESTRICTED*ACCESS, MANAGE*SECRET*MANAGERS, MANAGE*SECRETS, MANAGE*SSH*AND*WINRM, MANAGE*TAGS, MANAGE*TEMPLATE*LIBRARY, MANAGE*USER*AND*USER*GROUPS*AND*API*KEYS, MANAGE*USERS*AND*GROUPS, READ*USERS*AND*GROUPS, VIEW*AUDITS, VIEW*USER*AND*USER*GROUPS*AND*API_KEYS
     */
    accountPermissions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Application specific permissions
     */
    appPermissions?: pulumi.Input<inputs.UserGroupPermissionsAppPermissions>;
}

export interface UserGroupPermissionsAppPermissions {
    /**
     * The permission to perform actions against all resources.
     */
    alls?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsAll>[]>;
    /**
     * Permission configuration to perform actions against deployments.
     */
    deployments?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsDeployment>[]>;
    /**
     * Permission configuration to perform actions against workflows.
     */
    environments?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsEnvironment>[]>;
    /**
     * Permission configuration to perform actions against pipelines.
     */
    pipelines?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsPipeline>[]>;
    /**
     * Permission configuration to perform actions against provisioners.
     */
    provisioners?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsProvisioner>[]>;
    /**
     * Permission configuration to perform actions against services.
     */
    services?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsService>[]>;
    /**
     * Permission configuration to perform actions against templates.
     */
    templates?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsTemplate>[]>;
    /**
     * Permission configuration to perform actions against workflows.
     */
    workflows?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsWorkflow>[]>;
}

export interface UserGroupPermissionsAppPermissionsAll {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsDeployment {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    envIds?: pulumi.Input<pulumi.Input<string>[]>;
    filters: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsEnvironment {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    envIds?: pulumi.Input<pulumi.Input<string>[]>;
    filters: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsPipeline {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    envIds?: pulumi.Input<pulumi.Input<string>[]>;
    filters: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsProvisioner {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    provisionerIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsService {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    serviceIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsTemplate {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    templateIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsWorkflow {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    filters: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupSamlSettings {
    /**
     * The group name of the SAML user group.
     */
    groupName?: pulumi.Input<string>;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: pulumi.Input<string>;
}
export namespace cloudprovider {
    export interface AwsAssumeCrossAccountRole {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: pulumi.Input<string>;
        /**
         * This is an IAM role in the target deployment AWS account.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }

    export interface DatacenterUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }

    export interface GcpUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }

    export interface KubernetesAuthentication {
        /**
         * Delegate selectors to inherit the GCP credentials from.
         */
        delegateSelectors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Service account configuration for connecting to the Kubernetes cluster
         */
        oidc?: pulumi.Input<inputs.cloudprovider.KubernetesAuthenticationOidc>;
        /**
         * Username and password for authentication to the cluster
         */
        serviceAccount?: pulumi.Input<inputs.cloudprovider.KubernetesAuthenticationServiceAccount>;
        /**
         * Username and password for authentication to the cluster
         */
        usernamePassword?: pulumi.Input<inputs.cloudprovider.KubernetesAuthenticationUsernamePassword>;
    }

    export interface KubernetesAuthenticationOidc {
        clientIdSecretName: pulumi.Input<string>;
        clientSecretSecretName?: pulumi.Input<string>;
        identityProviderUrl: pulumi.Input<string>;
        masterUrl: pulumi.Input<string>;
        passwordSecretName: pulumi.Input<string>;
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        username: pulumi.Input<string>;
    }

    export interface KubernetesAuthenticationServiceAccount {
        caCertificateSecretName?: pulumi.Input<string>;
        masterUrl: pulumi.Input<string>;
        serviceAccountTokenSecretName: pulumi.Input<string>;
    }

    export interface KubernetesAuthenticationUsernamePassword {
        masterUrl: pulumi.Input<string>;
        passwordSecretName: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameSecretName?: pulumi.Input<string>;
    }

    export interface KubernetesUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }
}

export namespace platform {
    export interface AppDynamicsConnectorApiToken {
        /**
         * The client id used for connecting to App Dynamics.
         */
        clientId: pulumi.Input<string>;
        /**
         * Reference to the Harness secret containing the App Dynamics client secret.
         */
        clientSecretRef: pulumi.Input<string>;
    }

    export interface AppDynamicsConnectorUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username: pulumi.Input<string>;
    }

    export interface ArtifactoryConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface AwsCCConnectorCrossAccountAccess {
        /**
         * The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
         */
        externalId: pulumi.Input<string>;
        /**
         * The ARN of the role to use for cross-account access.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsConnectorCrossAccountAccess {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsConnectorInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AwsConnectorIrsa {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AwsConnectorManual {
        /**
         * AWS access key.
         */
        accessKey?: pulumi.Input<string>;
        /**
         * Reference to the Harness secret containing the aws access key.
         */
        accessKeyRef?: pulumi.Input<string>;
        /**
         * Connect only use delegates with these tags.
         */
        delegateSelectors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Reference to the Harness secret containing the aws secret key.
         */
        secretKeyRef: pulumi.Input<string>;
    }

    export interface AwsKmsConnectorCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: pulumi.Input<inputs.platform.AwsKmsConnectorCredentialsAssumeRole>;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: pulumi.Input<boolean>;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: pulumi.Input<inputs.platform.AwsKmsConnectorCredentialsManual>;
    }

    export interface AwsKmsConnectorCredentialsAssumeRole {
        duration: pulumi.Input<number>;
        externalId?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface AwsKmsConnectorCredentialsManual {
        accessKeyRef: pulumi.Input<string>;
        secretKeyRef: pulumi.Input<string>;
    }

    export interface AwsSecretManagerConnectorCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: pulumi.Input<inputs.platform.AwsSecretManagerConnectorCredentialsAssumeRole>;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: pulumi.Input<boolean>;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: pulumi.Input<inputs.platform.AwsSecretManagerConnectorCredentialsManual>;
    }

    export interface AwsSecretManagerConnectorCredentialsAssumeRole {
        duration: pulumi.Input<number>;
        externalId?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface AwsSecretManagerConnectorCredentialsManual {
        accessKeyRef: pulumi.Input<string>;
        secretKeyRef: pulumi.Input<string>;
    }

    export interface BitbucketConnectorApiAuthentication {
        /**
         * Personal access token for interacting with the BitBucket api.
         */
        tokenRef: pulumi.Input<string>;
        /**
         * The username used for connecting to the api.
         */
        username?: pulumi.Input<string>;
        /**
         * The name of the Harness secret containing the username.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface BitbucketConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.platform.BitbucketConnectorCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.platform.BitbucketConnectorCredentialsSsh>;
    }

    export interface BitbucketConnectorCredentialsHttp {
        passwordRef?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface BitbucketConnectorCredentialsSsh {
        sshKeyRef: pulumi.Input<string>;
    }

    export interface DockerConnectorCredentials {
        /**
         * The reference to the password to use for the docker registry.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * The username to use for the docker registry.
         */
        username?: pulumi.Input<string>;
        /**
         * The reference to the username to use for the docker registry.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface EnvironmentClustersMappingCluster {
        /**
         * account Identifier of the account
         */
        identifier?: pulumi.Input<string>;
        /**
         * name of the cluster
         */
        name?: pulumi.Input<string>;
        /**
         * scope at which the cluster exists in harness gitops, project vs org vs account
         */
        scope?: pulumi.Input<string>;
    }

    export interface GcpConnectorInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GcpConnectorManual {
        /**
         * The delegates to connect with.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Reference to the Harness secret containing the secret key.
         */
        secretKeyRef: pulumi.Input<string>;
    }

    export interface GetGitopsAgentMetadata {
        highAvailability?: boolean;
        namespace: string;
    }

    export interface GetGitopsAgentMetadataArgs {
        highAvailability?: pulumi.Input<boolean>;
        namespace: pulumi.Input<string>;
    }

    export interface GetGitopsClusterQuery {
        ids?: inputs.platform.GetGitopsClusterQueryId[];
        name?: string;
        server?: string;
    }

    export interface GetGitopsClusterQueryArgs {
        ids?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterQueryIdArgs>[]>;
        name?: pulumi.Input<string>;
        server?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterQueryId {
        type?: string;
        value?: string;
    }

    export interface GetGitopsClusterQueryIdArgs {
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterRequest {
        clusters?: inputs.platform.GetGitopsClusterRequestCluster[];
        ids?: inputs.platform.GetGitopsClusterRequestId[];
        updateMasks?: inputs.platform.GetGitopsClusterRequestUpdateMask[];
        updatedFields?: string[];
        upsert?: boolean;
    }

    export interface GetGitopsClusterRequestArgs {
        clusters?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterRequestClusterArgs>[]>;
        ids?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterRequestIdArgs>[]>;
        updateMasks?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterRequestUpdateMaskArgs>[]>;
        updatedFields?: pulumi.Input<pulumi.Input<string>[]>;
        upsert?: pulumi.Input<boolean>;
    }

    export interface GetGitopsClusterRequestCluster {
        annotations?: {[key: string]: string};
        clusterResources?: boolean;
        configs?: inputs.platform.GetGitopsClusterRequestClusterConfig[];
        infos?: inputs.platform.GetGitopsClusterRequestClusterInfo[];
        labels?: {[key: string]: string};
        name?: string;
        namespaces?: string[];
        project?: string;
        refreshRequestedAts?: inputs.platform.GetGitopsClusterRequestClusterRefreshRequestedAt[];
        server: string;
        shard?: string;
    }

    export interface GetGitopsClusterRequestClusterArgs {
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        clusterResources?: pulumi.Input<boolean>;
        configs?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterRequestClusterConfigArgs>[]>;
        infos?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterRequestClusterInfoArgs>[]>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        name?: pulumi.Input<string>;
        namespaces?: pulumi.Input<pulumi.Input<string>[]>;
        project?: pulumi.Input<string>;
        refreshRequestedAts?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterRequestClusterRefreshRequestedAtArgs>[]>;
        server: pulumi.Input<string>;
        shard?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterRequestClusterConfig {
        awsAuthConfigs?: inputs.platform.GetGitopsClusterRequestClusterConfigAwsAuthConfig[];
        bearerToken?: string;
        clusterConnectionType?: string;
        execProviderConfigs?: inputs.platform.GetGitopsClusterRequestClusterConfigExecProviderConfig[];
        password?: string;
        tlsClientConfigs?: inputs.platform.GetGitopsClusterRequestClusterConfigTlsClientConfig[];
        username?: string;
    }

    export interface GetGitopsClusterRequestClusterConfigArgs {
        awsAuthConfigs?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterRequestClusterConfigAwsAuthConfigArgs>[]>;
        bearerToken?: pulumi.Input<string>;
        clusterConnectionType?: pulumi.Input<string>;
        execProviderConfigs?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterRequestClusterConfigExecProviderConfigArgs>[]>;
        password?: pulumi.Input<string>;
        tlsClientConfigs?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterRequestClusterConfigTlsClientConfigArgs>[]>;
        username?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterRequestClusterConfigAwsAuthConfig {
        clusterName?: string;
        roleARN?: string;
    }

    export interface GetGitopsClusterRequestClusterConfigAwsAuthConfigArgs {
        clusterName?: pulumi.Input<string>;
        roleARN?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterRequestClusterConfigExecProviderConfig {
        apiVersion?: string;
        args?: string[];
        command?: string;
        env?: {[key: string]: string};
        installHint?: string;
    }

    export interface GetGitopsClusterRequestClusterConfigExecProviderConfigArgs {
        apiVersion?: pulumi.Input<string>;
        args?: pulumi.Input<pulumi.Input<string>[]>;
        command?: pulumi.Input<string>;
        env?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        installHint?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterRequestClusterConfigTlsClientConfig {
        caData?: string;
        certData?: string;
        insecure?: boolean;
        keyData?: string;
        serverName?: string;
    }

    export interface GetGitopsClusterRequestClusterConfigTlsClientConfigArgs {
        caData?: pulumi.Input<string>;
        certData?: pulumi.Input<string>;
        insecure?: pulumi.Input<boolean>;
        keyData?: pulumi.Input<string>;
        serverName?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterRequestClusterInfo {
        apiVersions?: string[];
        applicationsCount?: string;
        cacheInfos?: inputs.platform.GetGitopsClusterRequestClusterInfoCacheInfo[];
        connectionStates?: inputs.platform.GetGitopsClusterRequestClusterInfoConnectionState[];
        serverVersion?: string;
    }

    export interface GetGitopsClusterRequestClusterInfoArgs {
        apiVersions?: pulumi.Input<pulumi.Input<string>[]>;
        applicationsCount?: pulumi.Input<string>;
        cacheInfos?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterRequestClusterInfoCacheInfoArgs>[]>;
        connectionStates?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterRequestClusterInfoConnectionStateArgs>[]>;
        serverVersion?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterRequestClusterInfoCacheInfo {
        apisCount?: string;
        lastCacheSyncTime?: string;
        resourcesCount?: string;
    }

    export interface GetGitopsClusterRequestClusterInfoCacheInfoArgs {
        apisCount?: pulumi.Input<string>;
        lastCacheSyncTime?: pulumi.Input<string>;
        resourcesCount?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterRequestClusterInfoConnectionState {
        attemptedAts?: inputs.platform.GetGitopsClusterRequestClusterInfoConnectionStateAttemptedAt[];
        message?: string;
        status?: string;
    }

    export interface GetGitopsClusterRequestClusterInfoConnectionStateArgs {
        attemptedAts?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsClusterRequestClusterInfoConnectionStateAttemptedAtArgs>[]>;
        message?: pulumi.Input<string>;
        status?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterRequestClusterInfoConnectionStateAttemptedAt {
        nanos?: number;
        seconds?: string;
    }

    export interface GetGitopsClusterRequestClusterInfoConnectionStateAttemptedAtArgs {
        nanos?: pulumi.Input<number>;
        seconds?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterRequestClusterRefreshRequestedAt {
        nanos?: number;
        seconds?: string;
    }

    export interface GetGitopsClusterRequestClusterRefreshRequestedAtArgs {
        nanos?: pulumi.Input<number>;
        seconds?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterRequestId {
        type?: string;
        value?: string;
    }

    export interface GetGitopsClusterRequestIdArgs {
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GetGitopsClusterRequestUpdateMask {
        paths?: any[][];
    }

    export interface GetGitopsClusterRequestUpdateMaskArgs {
        paths?: pulumi.Input<pulumi.Input<any[]>[]>;
    }

    export interface GetGitopsRepositoryRepo {
        connectionType: string;
        enableLfs?: boolean;
        enableOci?: boolean;
        githubAppEnterpriseBaseUrl?: string;
        githubAppId?: string;
        githubAppInstallationId?: string;
        githubAppPrivateKey?: string;
        inheritedCreds?: boolean;
        insecure?: boolean;
        insecureIgnoreHostKey?: boolean;
        name?: string;
        password?: string;
        project?: string;
        proxy?: string;
        repo: string;
        sshPrivateKey?: string;
        tlsClientCertData?: string;
        tlsClientCertKey?: string;
        type_?: string;
        username?: string;
    }

    export interface GetGitopsRepositoryRepoArgs {
        connectionType: pulumi.Input<string>;
        enableLfs?: pulumi.Input<boolean>;
        enableOci?: pulumi.Input<boolean>;
        githubAppEnterpriseBaseUrl?: pulumi.Input<string>;
        githubAppId?: pulumi.Input<string>;
        githubAppInstallationId?: pulumi.Input<string>;
        githubAppPrivateKey?: pulumi.Input<string>;
        inheritedCreds?: pulumi.Input<boolean>;
        insecure?: pulumi.Input<boolean>;
        insecureIgnoreHostKey?: pulumi.Input<boolean>;
        name?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
        project?: pulumi.Input<string>;
        proxy?: pulumi.Input<string>;
        repo: pulumi.Input<string>;
        sshPrivateKey?: pulumi.Input<string>;
        tlsClientCertData?: pulumi.Input<string>;
        tlsClientCertKey?: pulumi.Input<string>;
        type_?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

    export interface GetGitopsRepositoryUpdateMask {
        paths?: string[];
    }

    export interface GetGitopsRepositoryUpdateMaskArgs {
        paths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GetRoleAssignmentsPrincipal {
        /**
         * Identifier.
         */
        identifier?: string;
        /**
         * Scope level.
         */
        scopeLevel?: string;
        /**
         * Type.
         */
        type?: string;
    }

    export interface GetRoleAssignmentsPrincipalArgs {
        /**
         * Identifier.
         */
        identifier?: pulumi.Input<string>;
        /**
         * Scope level.
         */
        scopeLevel?: pulumi.Input<string>;
        /**
         * Type.
         */
        type?: pulumi.Input<string>;
    }

    export interface GetUsergroupNotificationConfig {
        /**
         * Group email
         */
        groupEmail?: string;
        /**
         * Url of Microsoft teams webhook
         */
        microsoftTeamsWebhookUrl?: string;
        /**
         * Pager duty key
         */
        pagerDutyKey?: string;
        /**
         * Url of slack webhook
         */
        slackWebhookUrl?: string;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS
         */
        type?: string;
    }

    export interface GetUsergroupNotificationConfigArgs {
        /**
         * Group email
         */
        groupEmail?: pulumi.Input<string>;
        /**
         * Url of Microsoft teams webhook
         */
        microsoftTeamsWebhookUrl?: pulumi.Input<string>;
        /**
         * Pager duty key
         */
        pagerDutyKey?: pulumi.Input<string>;
        /**
         * Url of slack webhook
         */
        slackWebhookUrl?: pulumi.Input<string>;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS
         */
        type?: pulumi.Input<string>;
    }

    export interface GitConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.platform.GitConnectorCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.platform.GitConnectorCredentialsSsh>;
    }

    export interface GitConnectorCredentialsHttp {
        passwordRef: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface GitConnectorCredentialsSsh {
        sshKeyRef: pulumi.Input<string>;
    }

    export interface GitOpsAgentMetadata {
        highAvailability?: pulumi.Input<boolean>;
        namespace?: pulumi.Input<string>;
    }

    export interface GitOpsClusterQuery {
        ids?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterQueryId>[]>;
        name?: pulumi.Input<string>;
        server?: pulumi.Input<string>;
    }

    export interface GitOpsClusterQueryId {
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequest {
        clusters?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestCluster>[]>;
        ids?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestId>[]>;
        updateMasks?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestUpdateMask>[]>;
        updatedFields?: pulumi.Input<pulumi.Input<string>[]>;
        upsert?: pulumi.Input<boolean>;
    }

    export interface GitOpsClusterRequestCluster {
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        clusterResources?: pulumi.Input<boolean>;
        configs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterConfig>[]>;
        infos?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterInfo>[]>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        name?: pulumi.Input<string>;
        namespaces?: pulumi.Input<pulumi.Input<string>[]>;
        project?: pulumi.Input<string>;
        refreshRequestedAts?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterRefreshRequestedAt>[]>;
        server: pulumi.Input<string>;
        shard?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterConfig {
        awsAuthConfigs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterConfigAwsAuthConfig>[]>;
        bearerToken?: pulumi.Input<string>;
        clusterConnectionType?: pulumi.Input<string>;
        execProviderConfigs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterConfigExecProviderConfig>[]>;
        password?: pulumi.Input<string>;
        tlsClientConfigs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterConfigTlsClientConfig>[]>;
        username?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterConfigAwsAuthConfig {
        clusterName?: pulumi.Input<string>;
        roleARN?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterConfigExecProviderConfig {
        apiVersion?: pulumi.Input<string>;
        args?: pulumi.Input<pulumi.Input<string>[]>;
        command?: pulumi.Input<string>;
        env?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        installHint?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterConfigTlsClientConfig {
        caData?: pulumi.Input<string>;
        certData?: pulumi.Input<string>;
        insecure?: pulumi.Input<boolean>;
        keyData?: pulumi.Input<string>;
        serverName?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterInfo {
        apiVersions?: pulumi.Input<pulumi.Input<string>[]>;
        applicationsCount?: pulumi.Input<string>;
        cacheInfos?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterInfoCacheInfo>[]>;
        connectionStates?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterInfoConnectionState>[]>;
        serverVersion?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterInfoCacheInfo {
        apisCount?: pulumi.Input<string>;
        lastCacheSyncTime?: pulumi.Input<string>;
        resourcesCount?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterInfoConnectionState {
        attemptedAts?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterInfoConnectionStateAttemptedAt>[]>;
        message?: pulumi.Input<string>;
        status?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterInfoConnectionStateAttemptedAt {
        nanos?: pulumi.Input<number>;
        seconds?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterRefreshRequestedAt {
        nanos?: pulumi.Input<number>;
        seconds?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestId {
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestUpdateMask {
        paths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GitOpsRepositoryRepo {
        connectionType: pulumi.Input<string>;
        enableLfs?: pulumi.Input<boolean>;
        enableOci?: pulumi.Input<boolean>;
        githubAppEnterpriseBaseUrl?: pulumi.Input<string>;
        githubAppId?: pulumi.Input<string>;
        githubAppInstallationId?: pulumi.Input<string>;
        githubAppPrivateKey?: pulumi.Input<string>;
        inheritedCreds?: pulumi.Input<boolean>;
        insecure?: pulumi.Input<boolean>;
        insecureIgnoreHostKey?: pulumi.Input<boolean>;
        name?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
        project?: pulumi.Input<string>;
        proxy?: pulumi.Input<string>;
        repo: pulumi.Input<string>;
        sshPrivateKey?: pulumi.Input<string>;
        tlsClientCertData?: pulumi.Input<string>;
        tlsClientCertKey?: pulumi.Input<string>;
        type_?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

    export interface GitOpsRepositoryUpdateMask {
        paths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GithubConnectorApiAuthentication {
        /**
         * Configuration for using the github app for interacting with the github api.
         */
        githubApp?: pulumi.Input<inputs.platform.GithubConnectorApiAuthenticationGithubApp>;
        /**
         * Personal access token for interacting with the github api.
         */
        tokenRef?: pulumi.Input<string>;
    }

    export interface GithubConnectorApiAuthenticationGithubApp {
        applicationId: pulumi.Input<string>;
        installationId: pulumi.Input<string>;
        privateKeyRef: pulumi.Input<string>;
    }

    export interface GithubConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.platform.GithubConnectorCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.platform.GithubConnectorCredentialsSsh>;
    }

    export interface GithubConnectorCredentialsHttp {
        tokenRef: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface GithubConnectorCredentialsSsh {
        sshKeyRef: pulumi.Input<string>;
    }

    export interface GitlabConnectorApiAuthentication {
        /**
         * Personal access token for interacting with the gitlab api.
         */
        tokenRef: pulumi.Input<string>;
    }

    export interface GitlabConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.platform.GitlabConnectorCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.platform.GitlabConnectorCredentialsSsh>;
    }

    export interface GitlabConnectorCredentialsHttp {
        passwordRef?: pulumi.Input<string>;
        tokenRef?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface GitlabConnectorCredentialsSsh {
        sshKeyRef: pulumi.Input<string>;
    }

    export interface HelmConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface KubernetesConnectorClientKeyCert {
        /**
         * Reference to the secret containing the CA certificate for the connector.
         */
        caCertRef?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the client certificate for the connector.
         */
        clientCertRef: pulumi.Input<string>;
        /**
         * The algorithm used to generate the client key for the connector. Valid values are RSA, EC
         */
        clientKeyAlgorithm: pulumi.Input<string>;
        /**
         * Reference to the secret containing the client key passphrase for the connector.
         */
        clientKeyPassphraseRef?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the client key for the connector.
         */
        clientKeyRef: pulumi.Input<string>;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
    }

    export interface KubernetesConnectorInheritFromDelegate {
        /**
         * Selectors to use for the delegate.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface KubernetesConnectorOpenidConnect {
        /**
         * Reference to the secret containing the client ID for the connector.
         */
        clientIdRef: pulumi.Input<string>;
        /**
         * The URL of the OpenID Connect issuer.
         */
        issuerUrl: pulumi.Input<string>;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Reference to the secret containing the password for the connector.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Scopes to request for the connector.
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Reference to the secret containing the client secret for the connector.
         */
        secretRef?: pulumi.Input<string>;
        /**
         * Username for the connector.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the username for the connector.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface KubernetesConnectorServiceAccount {
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Reference to the secret containing the service account token for the connector.
         */
        serviceAccountTokenRef: pulumi.Input<string>;
    }

    export interface KubernetesConnectorUsernamePassword {
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Reference to the secret containing the password for the connector.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username for the connector.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the username for the connector.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface NexusConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface PrometheusConnectorHeader {
        /**
         * Encrypted value reference.
         */
        encryptedValueRef?: pulumi.Input<string>;
        /**
         * Key.
         */
        key: pulumi.Input<string>;
        /**
         * Value.
         */
        value?: pulumi.Input<string>;
        /**
         * Encrypted value.
         */
        valueEncrypted?: pulumi.Input<boolean>;
    }

    export interface ResourceGroupIncludedScope {
        /**
         * Account Identifier of the account
         */
        accountId?: pulumi.Input<string>;
        /**
         * Can be one of these 2 EXCLUDING*CHILD*SCOPES or INCLUDING*CHILD*SCOPES
         */
        filter: pulumi.Input<string>;
        /**
         * Organization Identifier
         */
        orgId?: pulumi.Input<string>;
        /**
         * Project Identifier
         */
        projectId?: pulumi.Input<string>;
    }

    export interface ResourceGroupResourceFilter {
        /**
         * Include all resource or not
         */
        includeAllResources?: pulumi.Input<boolean>;
        /**
         * Resources for a resource group
         */
        resources?: pulumi.Input<pulumi.Input<inputs.platform.ResourceGroupResourceFilterResource>[]>;
    }

    export interface ResourceGroupResourceFilterResource {
        attributeFilters?: pulumi.Input<pulumi.Input<inputs.platform.ResourceGroupResourceFilterResourceAttributeFilter>[]>;
        identifiers?: pulumi.Input<pulumi.Input<string>[]>;
        resourceType: pulumi.Input<string>;
    }

    export interface ResourceGroupResourceFilterResourceAttributeFilter {
        attributeName?: pulumi.Input<string>;
        attributeValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RoleAssignmentsPrincipal {
        /**
         * Identifier.
         */
        identifier?: pulumi.Input<string>;
        /**
         * Scope level.
         */
        scopeLevel?: pulumi.Input<string>;
        /**
         * Type.
         */
        type?: pulumi.Input<string>;
    }

    export interface SecretSshkeyKerberos {
        /**
         * Username to use for authentication.
         */
        principal: pulumi.Input<string>;
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        realm: pulumi.Input<string>;
        /**
         * Method to generate tgt
         */
        tgtGenerationMethod?: pulumi.Input<string>;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtKeyTabFilePathSpec?: pulumi.Input<inputs.platform.SecretSshkeyKerberosTgtKeyTabFilePathSpec>;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtPasswordSpec?: pulumi.Input<inputs.platform.SecretSshkeyKerberosTgtPasswordSpec>;
    }

    export interface SecretSshkeyKerberosTgtKeyTabFilePathSpec {
        keyPath?: pulumi.Input<string>;
    }

    export interface SecretSshkeyKerberosTgtPasswordSpec {
        password?: pulumi.Input<string>;
    }

    export interface SecretSshkeySsh {
        /**
         * This specifies SSH credential type as Password, KeyPath or KeyReference
         */
        credentialType: pulumi.Input<string>;
        /**
         * SSH credential of type keyReference
         */
        sshPasswordCredential?: pulumi.Input<inputs.platform.SecretSshkeySshSshPasswordCredential>;
        /**
         * SSH credential of type keyPath
         */
        sshkeyPathCredential?: pulumi.Input<inputs.platform.SecretSshkeySshSshkeyPathCredential>;
        /**
         * SSH credential of type keyReference
         */
        sshkeyReferenceCredential?: pulumi.Input<inputs.platform.SecretSshkeySshSshkeyReferenceCredential>;
    }

    export interface SecretSshkeySshSshPasswordCredential {
        password: pulumi.Input<string>;
        userName: pulumi.Input<string>;
    }

    export interface SecretSshkeySshSshkeyPathCredential {
        encryptedPassphrase?: pulumi.Input<string>;
        keyPath: pulumi.Input<string>;
        userName: pulumi.Input<string>;
    }

    export interface SecretSshkeySshSshkeyReferenceCredential {
        encryptedPassphrase?: pulumi.Input<string>;
        key?: pulumi.Input<string>;
        userName: pulumi.Input<string>;
    }

    export interface UsergroupNotificationConfig {
        /**
         * Group email
         */
        groupEmail?: pulumi.Input<string>;
        /**
         * Url of Microsoft teams webhook
         */
        microsoftTeamsWebhookUrl?: pulumi.Input<string>;
        /**
         * Pager duty key
         */
        pagerDutyKey?: pulumi.Input<string>;
        /**
         * Url of slack webhook
         */
        slackWebhookUrl?: pulumi.Input<string>;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS
         */
        type?: pulumi.Input<string>;
    }

    export interface VariablesSpec {
        /**
         * FixedValue of the variable
         */
        fixedValue: pulumi.Input<string>;
        /**
         * Type of Value of the Variable. For now only FIXED is supported
         */
        valueType: pulumi.Input<string>;
    }
}

export namespace service {
    export interface AmiVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface CodedeployVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface EcsVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface HelmVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface KubernetesVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface LambdaVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface SshVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface TanzuVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface WinrmVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }
}
